<!doctype html><html lang=en-uk><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.148.2"><title>Let's build a Load Balancer in Rust - Part 2 | Marco Bacis</title><meta name=description content="This is the second part of the &ldquo;Build your own load balancer in rust&rdquo; series! In this post, we&rsquo;ll see how to implement a round-robin policy, to forward our requests to multiple backends."><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://marcobacis.com/blog/load-balancer-rust-2/cover.png"><meta name=twitter:title content="Let's build a Load Balancer in Rust - Part 2"><meta name=twitter:description content="This is the second part of the ‚ÄúBuild your own load balancer in rust‚Äù series! In this post, we‚Äôll see how to implement a round-robin policy, to forward our requests to multiple backends."><meta property="og:url" content="https://marcobacis.com/blog/load-balancer-rust-2/"><meta property="og:site_name" content="Marco Bacis"><meta property="og:title" content="Let's build a Load Balancer in Rust - Part 2"><meta property="og:description" content="This is the second part of the ‚ÄúBuild your own load balancer in rust‚Äù series! In this post, we‚Äôll see how to implement a round-robin policy, to forward our requests to multiple backends."><meta property="og:locale" content="en_uk"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2024-05-22T00:00:00+00:00"><meta property="article:modified_time" content="2025-08-25T17:33:57+02:00"><meta property="article:tag" content="Meetup"><meta property="article:tag" content="Open Source"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Load Balancer"><meta property="article:tag" content="System Programming"><meta property="og:image" content="https://marcobacis.com/blog/load-balancer-rust-2/cover.png"><link href=https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css rel=stylesheet integrity=sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T crossorigin=anonymous><script src=https://kit.fontawesome.com/06d3e22684.js crossorigin=anonymous></script><link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel=stylesheet><link href=/css/main.css rel=stylesheet><script defer src=https://umami.marcobacis.com/script.js data-website-id=435d89b9-0e4c-4831-9214-edf318b03138></script><link rel=alternate type=application/rss+xml href=https://marcobacis.com/blog/index.xml title="Marco Bacis Blog"></head><body><nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down"><div class="container pr-0"><a class=navbar-brand href=https://marcobacis.com//><span style=font-family:Righteous>Marco Bacis</span>
</a><button class=navbar-toggler type=button aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarMediumish><ul class="navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=/>Home</a></li><li class=nav-item><a class=nav-link href=/now>Now</a></li><li class=nav-item><a class=nav-link href=/blog>Blog</a></li><li class=nav-item><a class=nav-link href=/projects>Projects</a></li><li class=nav-item><a class=nav-link href=/publications>Publications</a></li><li class=nav-item><a class=nav-link href=/cv>CV</a></li><li class=nav-item><a class=nav-link href=/about>About</a></li></ul></div></div></nav><div class=site-content><div class=container><div class=main-content><div class=container><div class=row><div class="col-md-2 pl-0"><div class="share sticky-top sticky-top-offset"><ul><li class="ml-1 mr-1"><a target=_blank href="https://bsky.app/intent/compose?text=Let%27s%20build%20a%20Load%20Balancer%20in%20Rust%20-%20Part%202%20https%3a%2f%2fmarcobacis.com%2fblog%2fload-balancer-rust-2%2f" onclick='return window.open(this.href,"bluesky-share","width=550,height=435"),!1' title="Share on Bluesky" class=hover-primary><i class="fab fa-bluesky"></i></a></li><li class="ml-1 mr-1"><a target=_blank href="https://www.linkedin.com/sharing/share-offsite/?url=https%3a%2f%2fmarcobacis.com%2fblog%2fload-balancer-rust-2%2f" onclick='return window.open(this.href,"linkedin-share","width=550,height=435"),!1' title="Share on LinkedIn" class=hover-primary><i class="fab fa-linkedin-in"></i></a></li><li><a class="smoothscroll hover-primary" href=#comments title="Write a comment"><i class="fas fa-comment"></i></a></li></ul></div></div><div class="col-md-9 flex-first flex-md-unordered"><div class=mainheading><div class="row post-top-meta"><div class="col-xs-12 col-md-3 col-lg-2 text-center text-md-left mb-4 mb-md-0 md-nopad-right"><img class=author-thumb src=/images/avatar_real.webp alt="Marco Bacis"></div><div class="col-xs-12 col-md-9 col-lg-10 text-center text-md-left md-nopad-left"><a target=_blank class=link-dark>Marco Bacis</a><br><span class=author-description>Software Engineer / Tinkerer<br><i class="far fa-star"></i>
May 22, 2024
<i class="far fa-clock clock"></i>
9 min read</span></div></div><h1 class=posttitle>Let's build a Load Balancer in Rust - Part 2</h1></div><div class=featured-image><figure><img class="img-fluid image" src=https://marcobacis.com/blog/load-balancer-rust-2/cover.png alt></figure></div><div class=article-post><hr><div class=series-list><h3>"Build your own load balancer in Rust" series</h3><ul><li><a href=/blog/load-balancer-rust-1>Part 1: Setup and http forwarding</a></li><li>Part 2: Round-Robin Policy</li><li><a href=/blog/load-balancer-rust-3>Part 3: Healthcheck</a></li></ul><hr></div><p>Hi üëã welcome to a new post! This is the second part of the series &ldquo;Let&rsquo;s build a Load Balancer in rust&rdquo;.</p><p>In the <a href=https://marcobacis.com/blog/load-balancer-rust-1/ target=_blank>first post</a> we saw how to forward a single request to an upstream server, using <a href=https://actix.rs/ target=_blank>Actix</a> and <a href=https://docs.rs/reqwest/latest/reqwest/ target=_blank>Reqwest</a>.</p><p>Today we&rsquo;ll see how to implement a round-robin policy, to forward our requests to multiple backends!</p><h2 id=small-fix-in-the-handler>Small fix in the handler</h2><p>In the first part, we left a (small) code smell in the handler code, because we instantiate the <code>reqwest</code> client struct on each new request received:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> client <span style=color:#f92672>=</span> Client::new();
</span></span></code></pre></div><p>The fix is simple: we can add the client to the shared app data, and then use it inside the handler! In this way, we won&rsquo;t have to istantiate the client on every request. This is also explained in reqwest <a href=https://docs.rs/reqwest/latest/reqwest/struct.Client.html target=_blank>docs</a>: &ldquo;The¬†<code>Client</code>¬†holds a connection pool internally, so it is advised that you create one and¬†<strong>reuse</strong>¬†it.&rdquo;</p><p>I tried adding the client directly to the <code>LoadBalancer</code> struct without passing through Actix, but the compiler complained when defining the handler and I just left it as-is. If you know a better method, write a comment at the end of the post (or even better, create a PR on the <a href=https://github.com/marcobacis/coding-challenges/tree/main/load_balancer target=_blank>project repository</a> üòÅ).</p><h2 id=waiting-for-the-load-balancer-to-start>Waiting for the Load Balancer to start</h2><p>Before starting with the round-robin implementation, lets tidy up a bit the code from the first part. The first thing to do is to improve the test we wrote!</p><p>In the test, we create the load balancer server and wait for it to start up with a simple `sleep¬¥</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// The class under test, the load balancer itself
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> server <span style=color:#f92672>=</span> LoadBalancer::new(<span style=color:#ae81ff>8080</span>, <span style=color:#a6e22e>vec!</span>[mock_server.uri()]);
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> server_uri <span style=color:#f92672>=</span> server.uri();
</span></span><span style=display:flex><span>tokio::spawn(<span style=color:#66d9ef>async</span> <span style=color:#66d9ef>move</span> { server.run().<span style=color:#66d9ef>await</span> });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Wait for the server to be up (will fix this later)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>tokio::time::sleep(std::time::Duration::from_secs(<span style=color:#ae81ff>3</span>)).<span style=color:#66d9ef>await</span>;
</span></span></code></pre></div><p>Well, let&rsquo;s fix this and create a function to wait for the server to start!</p><p>For now, we&rsquo;ll assume that the load balancer is up when the web server itself starts. To do so, we can add a healthcheck endpoint simply with actix:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>HttpServer::new(<span style=color:#66d9ef>move</span> <span style=color:#f92672>||</span> {
</span></span><span style=display:flex><span>	App::new()
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Healthcheck endpoint always returning 200 OK
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		.route(<span style=color:#e6db74>&#34;/health&#34;</span>, web::get().to(HttpResponse::Ok))
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Handler to forward request (from first part)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		.default_service(web::to(Self::handler))
</span></span><span style=display:flex><span>		.app_data(data.clone())
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ...
</span></span></span></code></pre></div><p>To fix our test, we can wait for the healthcheck url to be available by trying multiple times and waiting for a 200 HTTP code. Here is an example function to do so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>wait_server_up</span>(client: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Client</span>, uri: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>, max_retries: <span style=color:#66d9ef>usize</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>let</span> health_uri <span style=color:#f92672>=</span> <span style=color:#a6e22e>format!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>/health&#34;</span>, uri);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> _ <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>max_retries {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>let</span> response <span style=color:#f92672>=</span> client.get(<span style=color:#f92672>&amp;</span>health_uri).send().<span style=color:#66d9ef>await</span>;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> response.is_ok() {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		tokio::time::sleep(std::time::Duration::from_secs(<span style=color:#ae81ff>1</span>)).<span style=color:#66d9ef>await</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>panic!</span>(<span style=color:#e6db74>&#34;Server didn&#39;t start...&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>With this method we can now replace the old <code>tokio::time::sleep</code>. Now we&rsquo;re ready to go on and start spamming multiple servers with our requests!</p><h2 id=creating-a-round-robin-policy>Creating a Round Robin Policy</h2><p>It&rsquo;s finally time to forward our requests among multiple servers!</p><p>Up until now, we have &ldquo;decided&rdquo; the upstream host to which we forward our requests in the <code>handler</code> method of the load balancer, but I think we should delegate and isolate this responsibility to a different module, such as a <em>Routing Policy</em>.</p><p>While our tests are still passing, we can afford to perform some <em><a href=https://martinfowler.com/articles/preparatory-refactoring-example.html target=_blank>preparatory refactoring</a></em>. As said by <a href="https://x.com/KentBeck/status/250733358307500032?lang=en" target=_blank>kent beck</a>: &ldquo;<em>make the change easy, then make the easy change</em>&rdquo;.</p><h3 id=routing-policy-trait>Routing Policy Trait</h3><p>What we want to obtain is a simple interface for a routing policy, which chooses the next server on every new request we receive on the load balancer, like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[async_trait]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>trait</span> RoutingPolicy {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>next</span>(<span style=color:#f92672>&amp;</span>self, request: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>HttpRequest</span>) -&gt; String;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>next</code> method takes the request reference and returns the host on which the load balancer should forward the request. We declare as <code>async</code> method, to indicate that the policy might wait for some I/O or other async operations (e.g. accessing shared data on the server, using a db/cache).</p><p>Why the <code>#[async_trait]</code> macro on top of the trait? The <a href=https://docs.rs/async-trait/latest/async_trait/ target=_blank>async_trait</a> crate allows to use a Trait containing async methods as <code>dyn</code> (e.g. use <code>dyn RoutingPolicy</code>, as we&rsquo;ll be doing below) instead of having to resort on generics to embed an async Trait inside another. The explanation is a bit complex (and I don&rsquo;t understand it completely¬†üòÖ), so refer to the crate documentation for more infos.</p><p>We can now use the policy trait inside our program (I won&rsquo;t bother you with all the code, just the fundamental bits):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>SafeRoutingPolicy</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>dyn</span> RoutingPolicy <span style=color:#f92672>+</span> Sync <span style=color:#f92672>+</span> Send;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// add policy to the load balancer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>LoadBalancer</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	data: <span style=color:#a6e22e>Data</span><span style=color:#f92672>&lt;</span>AppState<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// add policy to the app state
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>AppState</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	policy: Box<span style=color:#f92672>&lt;</span>SafeRoutingPolicy<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> LoadBalancer {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>handler</span>(req: <span style=color:#a6e22e>HttpRequest</span>,data: <span style=color:#a6e22e>web</span>::Data<span style=color:#f92672>&lt;</span>AppState<span style=color:#f92672>&gt;</span>,bytes: <span style=color:#a6e22e>web</span>::Bytes) -&gt; Result<span style=color:#f92672>&lt;</span>HttpResponse, Error<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Here we grab the next server host from the policy
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>let</span> server <span style=color:#f92672>=</span> data.policy.next(<span style=color:#f92672>&amp;</span>req).<span style=color:#66d9ef>await</span>;
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>let</span> uri <span style=color:#f92672>=</span> <span style=color:#a6e22e>format!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}{}</span><span style=color:#e6db74>&#34;</span>, server, req.uri());
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ... forward the request etc
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Notice the type alias <code>SafeRoutingPolicy</code>, which has also the <code>Send</code> and <code>Sync</code> trait. Why do we need them? The policy is stored in the shared app state, which may be accessed by multiple threads (actix can run the handler method on different threads).</p><p>The <code>actix_web::web::Data</code> struct is a wrapper around an <code>Arc</code>, which allows to access the structure from multiple threads.¬†However, that doesn&rsquo;t mean that the fields (e.g. the policy) are thread safe! This is also recalled by the compiler, which gives us a nice error if we don&rsquo;t require the policy to be <code>Sync + Send</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>error[E0277]: <span style=color:#960050;background-color:#1e0010>`</span>(<span style=color:#66d9ef>dyn</span> RoutingPolicy <span style=color:#f92672>+</span> &#39;static)<span style=color:#960050;background-color:#1e0010>`</span> cannot be shared between threads safely
</span></span><span style=display:flex><span>   <span style=color:#f92672>-</span>-&gt; <span style=color:#a6e22e>src</span><span style=color:#f92672>/</span>lib.rs:<span style=color:#ae81ff>45</span>:<span style=color:#ae81ff>25</span>
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>	  <span style=color:#75715e>// ... code
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   
</span></span><span style=display:flex><span><span style=color:#f92672>=</span> help: <span style=color:#a6e22e>the</span> <span style=color:#66d9ef>trait</span> <span style=color:#960050;background-color:#1e0010>`</span>Sync<span style=color:#960050;background-color:#1e0010>`</span> is not implemented <span style=color:#66d9ef>for</span> <span style=color:#960050;background-color:#1e0010>`</span>(<span style=color:#66d9ef>dyn</span> RoutingPolicy <span style=color:#f92672>+</span> &#39;static)<span style=color:#960050;background-color:#1e0010>`</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>=</span> note: <span style=color:#a6e22e>required</span> <span style=color:#66d9ef>for</span> <span style=color:#960050;background-color:#1e0010>`</span>Unique<span style=color:#f92672>&lt;</span>(<span style=color:#66d9ef>dyn</span> RoutingPolicy <span style=color:#f92672>+</span> &#39;static)<span style=color:#f92672>&gt;</span><span style=color:#960050;background-color:#1e0010>`</span> to implement <span style=color:#960050;background-color:#1e0010>`</span>Sync<span style=color:#960050;background-color:#1e0010>`</span>
</span></span><span style=display:flex><span>note: <span style=color:#a6e22e>required</span> because it appears within the <span style=color:#66d9ef>type</span> <span style=color:#960050;background-color:#1e0010>`</span>Box<span style=color:#f92672>&lt;</span>(<span style=color:#66d9ef>dyn</span> RoutingPolicy <span style=color:#f92672>+</span> &#39;static)<span style=color:#f92672>&gt;</span><span style=color:#960050;background-color:#1e0010>`</span>
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>   <span style=color:#75715e>// ..Box
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   
</span></span><span style=display:flex><span>   <span style=color:#f92672>-</span>-&gt; <span style=color:#a6e22e>src</span><span style=color:#f92672>/</span>lib.rs:<span style=color:#ae81ff>22</span>:<span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>22</span>  <span style=color:#f92672>|</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>AppState</span> {
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span>        <span style=color:#f92672>^^^^^^^^</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>=</span> note: <span style=color:#a6e22e>required</span> <span style=color:#66d9ef>for</span> <span style=color:#960050;background-color:#1e0010>`</span>Arc<span style=color:#f92672>&lt;</span>AppState<span style=color:#f92672>&gt;</span><span style=color:#960050;background-color:#1e0010>`</span> to implement <span style=color:#960050;background-color:#1e0010>`</span>Send<span style=color:#960050;background-color:#1e0010>`</span>
</span></span><span style=display:flex><span>note: <span style=color:#a6e22e>required</span> because it appears within the <span style=color:#66d9ef>type</span> <span style=color:#960050;background-color:#1e0010>`</span>Data<span style=color:#f92672>&lt;</span>AppState<span style=color:#f92672>&gt;</span><span style=color:#960050;background-color:#1e0010>`</span>
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>90</span>  <span style=color:#f92672>|</span> <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Data</span><span style=color:#f92672>&lt;</span>T: <span style=color:#f92672>?</span>Sized<span style=color:#f92672>&gt;</span>(Arc<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>);
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span>            <span style=color:#f92672>^^^^</span>
</span></span><span style=display:flex><span>note: <span style=color:#a6e22e>required</span> because it<span style=color:#a6e22e>&#39;s</span> used within this closure
</span></span><span style=display:flex><span>   <span style=color:#f92672>-</span>-&gt; <span style=color:#a6e22e>src</span><span style=color:#f92672>/</span>lib.rs:<span style=color:#ae81ff>45</span>:<span style=color:#ae81ff>25</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>45</span>  <span style=color:#f92672>|</span>         HttpServer::new(<span style=color:#66d9ef>move</span> <span style=color:#f92672>||</span> {
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span>                         <span style=color:#f92672>^^^^^^^</span>
</span></span><span style=display:flex><span>note: <span style=color:#a6e22e>required</span> by a bound <span style=color:#66d9ef>in</span> <span style=color:#960050;background-color:#1e0010>`</span>HttpServer::<span style=color:#f92672>&lt;</span>F, I, S, B<span style=color:#f92672>&gt;</span>::new<span style=color:#960050;background-color:#1e0010>`</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>-</span>-&gt; <span style=color:#f92672>/</span>Users<span style=color:#f92672>/</span>marco<span style=color:#f92672>/</span>.cargo<span style=color:#f92672>/</span>registry<span style=color:#f92672>/</span>src<span style=color:#f92672>/</span>index.crates.io<span style=color:#f92672>-</span><span style=color:#ae81ff>6</span>f17d22bba15001f<span style=color:#f92672>/</span>actix<span style=color:#f92672>-</span>web<span style=color:#f92672>-</span><span style=color:#ae81ff>4.5.1</span><span style=color:#f92672>/</span>src<span style=color:#f92672>/</span>server.rs:<span style=color:#ae81ff>94</span>:<span style=color:#ae81ff>20</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>94</span>  <span style=color:#f92672>|</span>     F: Fn() -&gt; <span style=color:#a6e22e>I</span> <span style=color:#f92672>+</span> Send <span style=color:#f92672>+</span> Clone <span style=color:#f92672>+</span> &#39;static,
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span>                    <span style=color:#f92672>^^^^</span> required by this bound <span style=color:#66d9ef>in</span> <span style=color:#960050;background-color:#1e0010>`</span>HttpServer::<span style=color:#f92672>&lt;</span>F, I, S, B<span style=color:#f92672>&gt;</span>::new<span style=color:#960050;background-color:#1e0010>`</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// same for Sync
</span></span></span></code></pre></div><p>Basically, the compiler is telling us that the policy variable is not safe to move or access among multiple threads:</p><ul><li><code>Send</code> means a type can be moved/sent to another thread (e.g. when we run the server by spawning the actix http handler)</li><li><code>Sync</code>means that the type can be shared and use between threads (e.g. by calling the policy <code>next</code> method from different threads)</li></ul><p>This is one of the reasons I like rust: the compiler enforces us to use safe abstractions (e.g. forcing my policy to be <code>Sync</code>, a.k.a. thread safe) and explains that clearly in the compilation output!</p><h3 id=single-server-policy>Single Server Policy</h3><p>To finish our preparatory refactoring, we need to implement a routing policy which allows to always return a single server (the same thing we were doing in Part 1).</p><p>Let&rsquo;s implement it and run the tests:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>SingleServerPolicy</span> {
</span></span><span style=display:flex><span>	server: String,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> SingleServerPolicy {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>(server: String) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>		Self { server: <span style=color:#a6e22e>server</span> }
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[async_trait]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> RoutingPolicy <span style=color:#66d9ef>for</span> SingleServerPolicy {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>next</span>(<span style=color:#f92672>&amp;</span>self, request: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>HttpRequest</span>) -&gt; String {
</span></span><span style=display:flex><span>		self.server.clone()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Notice the use of <code>#[async_trait]</code> here too, as it needs to be applied also to the async trait&rsquo;s implementation.</p><p>We can now remove the list of servers from the LoadBalancer struct (and constructor) and move it inside the policy, and we are ready to implement our round robin policy!!</p><h3 id=round-robin-policy-test>Round Robin Policy: Test</h3><p>The first thing to do is to write another test case for our load balancer, this time spawning multiple upstream servers and checking that they are called in the right order:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[tokio::test]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>test_round_robin_three_servers</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>let</span> mocks <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>		MockServer::start().<span style=color:#66d9ef>await</span>,
</span></span><span style=display:flex><span>		MockServer::start().<span style=color:#66d9ef>await</span>,
</span></span><span style=display:flex><span>		MockServer::start().<span style=color:#66d9ef>await</span>,
</span></span><span style=display:flex><span>	];
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	Mock::given(method(<span style=color:#e6db74>&#34;GET&#34;</span>))
</span></span><span style=display:flex><span>	.respond_with(ResponseTemplate::new(<span style=color:#ae81ff>200</span>).set_body_string(<span style=color:#e6db74>&#34;1&#34;</span>))
</span></span><span style=display:flex><span>	.mount(<span style=color:#f92672>&amp;</span>mocks[<span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>	.<span style=color:#66d9ef>await</span>;
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ... same for mock server 2 and 3, returning a different number
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>let</span> client <span style=color:#f92672>=</span> Client::new();
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>let</span> mock_uris: Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> mocks.iter().map(<span style=color:#f92672>|</span>mock<span style=color:#f92672>|</span> mock.uri()).collect();
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Spawn load balancer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>let</span> policy <span style=color:#f92672>=</span> Box::new(RoundRobinPolicy::new(mock_uris.clone()));
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>let</span> server <span style=color:#f92672>=</span> LoadBalancer::new(<span style=color:#ae81ff>8082</span>, policy);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>let</span> server_uri <span style=color:#f92672>=</span> server.uri();
</span></span><span style=display:flex><span>	tokio::spawn(<span style=color:#66d9ef>async</span> <span style=color:#66d9ef>move</span> { server.run().<span style=color:#66d9ef>await</span> });
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	wait_server_up(<span style=color:#f92672>&amp;</span>client, <span style=color:#f92672>&amp;</span>server_uri, <span style=color:#ae81ff>3</span>).<span style=color:#66d9ef>await</span>;
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Send requests, expect to respond in round robin (1,2,3,1)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>let</span> response <span style=color:#f92672>=</span> client.get(<span style=color:#f92672>&amp;</span>server_uri).send().<span style=color:#66d9ef>await</span>.unwrap();
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>assert_eq!</span>(StatusCode::<span style=color:#66d9ef>OK</span>, response.status());
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>assert_eq!</span>(<span style=color:#e6db74>&#34;1&#34;</span>, response.text().<span style=color:#66d9ef>await</span>.unwrap());
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>let</span> response <span style=color:#f92672>=</span> client.get(<span style=color:#f92672>&amp;</span>server_uri).send().<span style=color:#66d9ef>await</span>.unwrap();
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>assert_eq!</span>(StatusCode::<span style=color:#66d9ef>OK</span>, response.status());
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>assert_eq!</span>(<span style=color:#e6db74>&#34;2&#34;</span>, response.text().<span style=color:#66d9ef>await</span>.unwrap());
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>let</span> response <span style=color:#f92672>=</span> client.get(<span style=color:#f92672>&amp;</span>server_uri).send().<span style=color:#66d9ef>await</span>.unwrap();
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>assert_eq!</span>(StatusCode::<span style=color:#66d9ef>OK</span>, response.status());
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>assert_eq!</span>(<span style=color:#e6db74>&#34;3&#34;</span>, response.text().<span style=color:#66d9ef>await</span>.unwrap());
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>let</span> response <span style=color:#f92672>=</span> client.get(<span style=color:#f92672>&amp;</span>server_uri).send().<span style=color:#66d9ef>await</span>.unwrap();
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>assert_eq!</span>(StatusCode::<span style=color:#66d9ef>OK</span>, response.status());
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>assert_eq!</span>(<span style=color:#e6db74>&#34;1&#34;</span>, response.text().<span style=color:#66d9ef>await</span>.unwrap());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Right now the test doesn&rsquo;t even compile (we don&rsquo;t have a <code>RoundRobinPolicy</code>struct with a <code>new</code> method).</p><p>Let&rsquo;s fix that.</p><h3 id=round-robin-policy-implementation>Round Robin Policy: Implementation</h3><p>Here is the code for the <code>RoundRobinPolicy</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>RoundRobinPolicy</span> {
</span></span><span style=display:flex><span>	servers: Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>	idx: <span style=color:#a6e22e>AtomicUsize</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> RoundRobinPolicy {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>(servers: Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>		Self {
</span></span><span style=display:flex><span>			idx: <span style=color:#a6e22e>AtomicUsize</span>::new(<span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>			servers: <span style=color:#a6e22e>servers</span>.clone(),
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[async_trait]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> RoutingPolicy <span style=color:#66d9ef>for</span> RoundRobinPolicy {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>next</span>(<span style=color:#f92672>&amp;</span>self, _request: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>HttpRequest</span>) -&gt; String {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Read servers list
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>let</span> servers <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>self.servers;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>let</span> max_server_idx <span style=color:#f92672>=</span> servers.len() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	  
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Update index
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>let</span> idx <span style=color:#f92672>=</span> self
</span></span><span style=display:flex><span>		.idx
</span></span><span style=display:flex><span>		.fetch_update(Ordering::Relaxed, Ordering::Relaxed, <span style=color:#f92672>|</span>idx<span style=color:#f92672>|</span> <span style=color:#66d9ef>match</span> idx {
</span></span><span style=display:flex><span>			x <span style=color:#66d9ef>if</span> x <span style=color:#f92672>&gt;=</span> max_server_idx <span style=color:#f92672>=&gt;</span> Some(<span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>			c <span style=color:#f92672>=&gt;</span> Some(c <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>		})
</span></span><span style=display:flex><span>		.unwrap_or_default();
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Return next server to forward the request to
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		servers.get(idx).unwrap().clone()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>On each new request, the policy updates the current upstream server index and returns the corresponding url.</p><p>But why is the <code>idx</code> parameter an <code>AtomicUsize</code>? As explained in the <a href=https://doc.rust-lang.org/std/sync/atomic/struct.AtomicUsize.html target=_blank>documentation</a>, this type allows to safely share the underlying value between threads, as it can be updated atomically. In fact, we update the index with the <code>fetch_update</code> method, which allows to update the number and get the value in a single action, without risking data races and inconsistency when used by multiple threads.</p><p>The <code>Ordering:Relaxed</code>params indicate the ordering constraint to be enforced on the atomic operation. I tried to read the <a href=https://doc.rust-lang.org/nomicon/atomics.html target=_blank>book</a> but didn&rsquo;t understand it completely, so refer to that to learn more about this. For now, we&rsquo;re ok using <code>Relaxed</code> (we are updating a counter and nothing more).</p><p>Now we have a round robin policy and the test passes. We can also replace the <code>SingleServerPolicy</code> created earlier with our new one and remove that temporary struct used for the refactoring!</p><h2 id=conclusions>Conclusions</h2><p>This is the end of Part 2. We cleaned up the load balancer code from <a href=https://marcobacis.com/blog/load-balancer-rust-1/ target=_blank>Part 1</a>, and added a simple Round-Robin policy to balance the load among multiple upstream servers. The code for this part can be found <a href=https://gist.github.com/marcobacis/477191a3b908c27fd334137cf4b5ee1d target=_blank>here</a>.</p><p>Still, the <a href=https://codingchallenges.fyi/challenges/challenge-load-balancer target=_blank>coding challenge</a> is not finished&mldr;.the final step will be to periodically health check the upstream servers, in order to not forward the requests to the unavailable ones.</p><p>See you next time for Part 3!</p><h2 id=resources>Resources</h2><ul><li><a href=https://actix.rs/docs target=_blank>Actix Docs</a></li><li><a href=https://docs.rs/reqwest/latest/reqwest/ target=_blank>Reqwest Docs</a></li><li><a href=https://tokio.rs/tokio/tutorial target=_blank>Tokio Tutorial</a></li><li><a href=https://doc.rust-lang.org/nomicon/send-and-sync.html target=_blank>Send and Sync</a></li><li><a href=https://tontinton.com/posts/scheduling-internals/ target=_blank>Scheduling Internals</a> - Tony Solomonik</li><li><a href=https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/ target=_blank>Why async fn in traits are hard</a> - Niko Matsakis</li><li><a href=https://manishearth.github.io/blog/2015/05/27/wrapper-types-in-rust-choosing-your-guarantees/ target=_blank>Wrapper Types in Rust: Choosing Your Guarantees</a> - Manish Goregaokar</li></ul></div><div class=after-post-tags><ul class=tags><li><a href=/tags/meetup>meetup</a></li><li><a href=/tags/open-source>open source</a></li><li><a href=/tags/rust>rust</a></li><li><a href=/tags/load-balancer>load balancer</a></li><li><a href=/tags/system-programming>system programming</a></li></ul></div><div class="row PageNavigation d-flex justify-content-between font-weight-bold"><a class="d-block col-md-6" href=https://marcobacis.com/blog/load-balancer-rust-3/>&#171; Let's build a Load Balancer in Rust - Part 3</a>
<a class="d-block col-md-6 text-lg-right" href=https://marcobacis.com/blog/load-balancer-rust-1/>Let's build a Load Balancer in Rust - Part 1 &#187;</a><div class=clearfix></div></div></div></div></div><div class=container><div id=comments class="row justify-content-center mb-5"><div class=col-md-8><script src=https://utteranc.es/client.js repo=marcobacis/marcobacis.github.io issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></div></div></div></div></div><div class="jumbotron fortags"><div class="d-md-flex justify-content-center h-100"><div class="col-md-8 p-2 align-self-center text-center"><a class="mt-1 mb-1 flex align-items-center" href=/tags/summary>Summary <span class=round-badge>12</span>
</a><a class="mt-1 mb-1 flex align-items-center" href=/tags/meetup>Meetup <span class=round-badge>8</span>
</a><a class="mt-1 mb-1 flex align-items-center" href=/tags/conference>Conference <span class=round-badge>7</span>
</a><a class="mt-1 mb-1 flex align-items-center" href=/tags/architecture>Architecture <span class=round-badge>6</span>
</a><a class="mt-1 mb-1 flex align-items-center" href=/tags/programming>Programming <span class=round-badge>6</span>
</a><a class="mt-1 mb-1 flex align-items-center" href=/tags/self>Self <span class=round-badge>4</span>
</a><a class="mt-1 mb-1 flex align-items-center" href=/tags/xpug>Xpug <span class=round-badge>4</span>
</a><a class="mt-1 mb-1 flex align-items-center" href=/tags/books>Books <span class=round-badge>4</span>
</a><a class="mt-1 mb-1 flex align-items-center" href=/tags/journal>Journal <span class=round-badge>4</span>
</a><a class="mt-1 mb-1 flex align-items-center" href=/tags/agile>Agile <span class=round-badge>4</span>
</a><a class="mt-1 mb-1 flex align-items-center" href=/tags/retrospective>Retrospective <span class=round-badge>4</span>
</a><a class="mt-1 mb-1 flex align-items-center" href=/tags/tdd>Tdd <span class=round-badge>4</span>
</a><a class="mt-1 mb-1 flex align-items-center" href=/tags/notes>Notes <span class=round-badge>3</span>
</a><a class="mt-1 mb-1 flex align-items-center" href=/tags/productivity>Productivity <span class=round-badge>3</span>
</a><a class="mt-1 mb-1 flex align-items-center" href=/tags/load-balancer>Load Balancer <span class=round-badge>3</span>
</a><a class="mt-1 mb-1 flex align-items-center" href=/tags/rust>Rust <span class=round-badge>3</span>
</a><a class="mt-1 mb-1 flex align-items-center" href=/tags/system-programming>System Programming <span class=round-badge>3</span>
</a><a class="mt-1 mb-1 flex align-items-center" href=/tags/talks>Talks <span class=round-badge>3</span>
</a><a class="mt-1 mb-1 flex align-items-center" href=/tags/open-source>Open Source <span class=round-badge>3</span>
</a><a class="mt-1 mb-1 flex align-items-center" href=/tags/.net>.Net <span class=round-badge>3</span>
</a><a class="mt-1 mb-1 plain" href=/tags/>See All</a></div></div></div><footer class=footer><div class=container><div class=row><div class="col-md-6 col-sm-6 text-center text-lg-left">¬© Copyright Marco Bacis</div></div></div></footer></div><script src=/js/mediumish.js></script></body></html>