<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>Rust on Marco Bacis</title><link>https://marcobacis.com/tags/rust/</link><description>Recent content in Rust on Marco Bacis</description><language>en-uk</language><copyright>¬© Copyright Marco Bacis 2018-2024</copyright><lastBuildDate>Wed, 22 May 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://marcobacis.com/tags/rust/index.xml" rel="self" type="application/rss+xml"/><item><title>Let's build a Load Balancer in Rust - Part 2</title><link>https://marcobacis.com/blog/load-balancer-rust-2/</link><pubDate>Wed, 22 May 2024 00:00:00 +0000</pubDate><guid>https://marcobacis.com/blog/load-balancer-rust-2/</guid><description>Hi üëã welcome to a new post! This is the second part of the series &ldquo;Let&rsquo;s build a Load Balancer in rust&rdquo;.
In the first post we saw how to forward a single request to an upstream server, using Actix and Reqwest.
Today we&rsquo;ll see how to implement a round-robin policy, to forward our requests to multiple backends!
Small fix in the handler In the first part, we left a (small) code smell in the handler code, because we instantiate the reqwest client struct on each new request received:</description><media:content url="https://marcobacis.com/blog/load-balancer-rust-2/cover_hu0a658fabcd51b67511a2b4132d0b39d3_85848_480x480_fit_q75_bgffffff_box_3.jpg" width="480" height="480" medium="image" type="image/jpeg"><media:thumbnail url="https://marcobacis.com/blog/load-balancer-rust-2/cover_hu0a658fabcd51b67511a2b4132d0b39d3_85848_480x480_fit_q75_bgffffff_box_3.jpg" width="480" height="480"/></media:content><content:encoded><![CDATA[
        <img src="https://marcobacis.com/blog/load-balancer-rust-2/cover_hu0a658fabcd51b67511a2b4132d0b39d3_85848_480x480_fit_q75_bgffffff_box_3.jpg" title="%!s(<nil>)" alt="%!s(<nil>)"/>
          <p>Hi  üëã welcome to a new post! This is the second part of the series &ldquo;Let&rsquo;s build a Load Balancer in rust&rdquo;.</p>
<p>In the <a href="https://marcobacis.com/blog/load-balancer-rust-1/"  target="_blank" >first post</a> we saw how to forward a single request to an upstream server, using <a href="https://actix.rs/"  target="_blank" >Actix</a> and <a href="https://docs.rs/reqwest/latest/reqwest/"  target="_blank" >Reqwest</a>.</p>
<p>Today we&rsquo;ll see how to implement a round-robin policy, to forward our requests to multiple backends!</p>
<h2 id="small-fix-in-the-handler">Small fix in the handler</h2>
<p>In the first part, we left a (small) code smell in the handler code, because we instantiate the <code>reqwest</code> client struct on each new request received:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> Client::new();
</span></span></code></pre></div><p>The fix is simple: we can add the client to the shared app data, and then use it inside the handler! In this way, we won&rsquo;t have to istantiate the client on every request. This is also explained in reqwest <a href="https://docs.rs/reqwest/latest/reqwest/struct.Client.html"  target="_blank" >docs</a>: &ldquo;The¬†<code>Client</code>¬†holds a connection pool internally, so it is advised that you create one and¬†<strong>reuse</strong>¬†it.&rdquo;</p>
<p>I tried adding the client directly to the <code>LoadBalancer</code> struct without passing through Actix, but the compiler complained when defining the handler and I just left it as-is. If you know a better method, write a comment at the end of the post (or even better, create a PR on the <a href="https://github.com/marcobacis/coding-challenges/tree/main/load_balancer"  target="_blank" >project repository</a> üòÅ).</p>
<h2 id="waiting-for-the-load-balancer-to-start">Waiting for the Load Balancer to start</h2>
<p>Before starting with the round-robin implementation, lets tidy up a bit the code from the first part. The first thing to do is to improve the test we wrote!</p>
<p>In the test, we create the load balancer server and wait for it to start up with a simple `sleep¬¥</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// The class under test, the load balancer itself
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> server <span style="color:#f92672">=</span> LoadBalancer::new(<span style="color:#ae81ff">8080</span>, vec![mock_server.uri()]);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> server_uri <span style="color:#f92672">=</span> server.uri();
</span></span><span style="display:flex;"><span>tokio::spawn(<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> { server.run().<span style="color:#66d9ef">await</span> });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Wait for the server to be up (will fix this later)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>tokio::time::sleep(std::time::Duration::from_secs(<span style="color:#ae81ff">3</span>)).<span style="color:#66d9ef">await</span>;
</span></span></code></pre></div><p>Well, let&rsquo;s fix this and create a function to wait for the server to start!</p>
<p>For now, we&rsquo;ll assume that the load balancer is up when the web server itself starts. To do so, we can add a healthcheck endpoint simply with actix:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>HttpServer::new(<span style="color:#66d9ef">move</span> <span style="color:#f92672">||</span> {
</span></span><span style="display:flex;"><span>	App::new()
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Healthcheck endpoint always returning 200 OK
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		.route(<span style="color:#e6db74">&#34;/health&#34;</span>, web::get().to(HttpResponse::Ok))
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Handler to forward request (from first part)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		.default_service(web::to(Self::handler))
</span></span><span style="display:flex;"><span>		.app_data(data.clone())
</span></span><span style="display:flex;"><span>	})
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// ...
</span></span></span></code></pre></div><p>To fix our test, we can wait for the healthcheck url to be available by trying multiple times and waiting for a 200 HTTP code. Here is an example function to do so:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">wait_server_up</span>(client: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Client</span>, uri: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>, max_retries: <span style="color:#66d9ef">usize</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> health_uri <span style="color:#f92672">=</span> format!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">/health&#34;</span>, uri);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> _ <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>max_retries {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> response <span style="color:#f92672">=</span> client.get(<span style="color:#f92672">&amp;</span>health_uri).send().<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> response.is_ok() {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		tokio::time::sleep(std::time::Duration::from_secs(<span style="color:#ae81ff">1</span>)).<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	panic!(<span style="color:#e6db74">&#34;Server didn&#39;t start...&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>With this method we can now replace the old <code>tokio::time::sleep</code>. Now we&rsquo;re ready to go on and start spamming multiple servers with our requests!</p>
<h2 id="creating-a-round-robin-policy">Creating a Round Robin Policy</h2>
<p>It&rsquo;s finally time to forward our requests among multiple servers!</p>
<p>Up until now, we have &ldquo;decided&rdquo; the upstream host to which we forward our requests in the <code>handler</code> method of the load balancer, but I think we should delegate and isolate this responsibility to a different module, such as a <em>Routing Policy</em>.</p>
<p>While our tests are still passing, we can afford to perform some <em><a href="https://martinfowler.com/articles/preparatory-refactoring-example.html"  target="_blank" >preparatory refactoring</a></em>. As said by <a href="https://x.com/KentBeck/status/250733358307500032?lang=en"  target="_blank" >kent beck</a>: &ldquo;<em>make the change easy, then make the easy change</em>&rdquo;.</p>
<h3 id="routing-policy-trait">Routing Policy Trait</h3>
<p>What we want to obtain is a simple interface for a routing policy, which chooses the next server on every new request we receive on the load balancer, like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[async_trait]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> RoutingPolicy {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">next</span>(<span style="color:#f92672">&amp;</span>self, request: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">HttpRequest</span>) -&gt; String;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>next</code> method takes the request reference and returns the host on which the load balancer should forward the request. We declare as <code>async</code> method, to indicate that the policy might wait for some I/O or other async operations (e.g. accessing shared data on the server, using a db/cache).</p>
<p>Why the <code>#[async_trait]</code> macro on top of the trait? The <a href="https://docs.rs/async-trait/latest/async_trait/"  target="_blank" >async_trait</a> crate allows to use a Trait containing async methods as <code>dyn</code> (e.g. use <code>dyn RoutingPolicy</code>, as we&rsquo;ll be doing below) instead of having to resort on generics to embed an async Trait inside another. The explanation is a bit complex (and I don&rsquo;t understand it completely¬†üòÖ), so refer to the crate documentation for more infos.</p>
<p>We can now use the policy trait inside our program (I won&rsquo;t bother you with all the code, just the fundamental bits):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SafeRoutingPolicy</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">dyn</span> RoutingPolicy <span style="color:#f92672">+</span> Sync <span style="color:#f92672">+</span> Send;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// add policy to the load balancer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">LoadBalancer</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	data: <span style="color:#a6e22e">Data</span><span style="color:#f92672">&lt;</span>AppState<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// add policy to the app state
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">AppState</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	policy: Box<span style="color:#f92672">&lt;</span>SafeRoutingPolicy<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> LoadBalancer {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">handler</span>(req: <span style="color:#a6e22e">HttpRequest</span>,data: <span style="color:#a6e22e">web</span>::Data<span style="color:#f92672">&lt;</span>AppState<span style="color:#f92672">&gt;</span>,bytes: <span style="color:#a6e22e">web</span>::Bytes) -&gt; Result<span style="color:#f92672">&lt;</span>HttpResponse, Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Here we grab the next server host from the policy
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> server <span style="color:#f92672">=</span> data.policy.next(<span style="color:#f92672">&amp;</span>req).<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> uri <span style="color:#f92672">=</span> format!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}{}</span><span style="color:#e6db74">&#34;</span>, server, req.uri());
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// ... forward the request etc
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>Notice the type alias <code>SafeRoutingPolicy</code>, which has also the <code>Send</code> and <code>Sync</code> trait. Why do we need them? The policy is stored in the shared app state, which may be accessed by multiple threads (actix can run the handler method on different threads).</p>
<p>The <code>actix_web::web::Data</code> struct is a wrapper around an <code>Arc</code>, which allows to access the structure from multiple threads.¬†However, that doesn&rsquo;t mean that the fields (e.g. the policy) are thread safe! This is also recalled by the compiler, which gives us a nice error if we don&rsquo;t require the policy to be <code>Sync + Send</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>error[E0277]: <span style="color:#960050;background-color:#1e0010">`</span>(<span style="color:#66d9ef">dyn</span> RoutingPolicy <span style="color:#f92672">+</span> &#39;static)<span style="color:#960050;background-color:#1e0010">`</span> cannot be shared between threads safely
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">-</span>-&gt; <span style="color:#a6e22e">src</span><span style="color:#f92672">/</span>lib.rs:<span style="color:#ae81ff">45</span>:<span style="color:#ae81ff">25</span>
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span>	  <span style="color:#75715e">// ... code
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   
</span></span><span style="display:flex;"><span><span style="color:#f92672">=</span> help: <span style="color:#a6e22e">the</span> <span style="color:#66d9ef">trait</span> <span style="color:#960050;background-color:#1e0010">`</span>Sync<span style="color:#960050;background-color:#1e0010">`</span> is not implemented <span style="color:#66d9ef">for</span> <span style="color:#960050;background-color:#1e0010">`</span>(<span style="color:#66d9ef">dyn</span> RoutingPolicy <span style="color:#f92672">+</span> &#39;static)<span style="color:#960050;background-color:#1e0010">`</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">=</span> note: <span style="color:#a6e22e">required</span> <span style="color:#66d9ef">for</span> <span style="color:#960050;background-color:#1e0010">`</span>Unique<span style="color:#f92672">&lt;</span>(<span style="color:#66d9ef">dyn</span> RoutingPolicy <span style="color:#f92672">+</span> &#39;static)<span style="color:#f92672">&gt;</span><span style="color:#960050;background-color:#1e0010">`</span> to implement <span style="color:#960050;background-color:#1e0010">`</span>Sync<span style="color:#960050;background-color:#1e0010">`</span>
</span></span><span style="display:flex;"><span>note: <span style="color:#a6e22e">required</span> because it appears within the <span style="color:#66d9ef">type</span> <span style="color:#960050;background-color:#1e0010">`</span>Box<span style="color:#f92672">&lt;</span>(<span style="color:#66d9ef">dyn</span> RoutingPolicy <span style="color:#f92672">+</span> &#39;static)<span style="color:#f92672">&gt;</span><span style="color:#960050;background-color:#1e0010">`</span>
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// ..Box
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">-</span>-&gt; <span style="color:#a6e22e">src</span><span style="color:#f92672">/</span>lib.rs:<span style="color:#ae81ff">22</span>:<span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">22</span>  <span style="color:#f92672">|</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">AppState</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span>        <span style="color:#f92672">^^^^^^^^</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">=</span> note: <span style="color:#a6e22e">required</span> <span style="color:#66d9ef">for</span> <span style="color:#960050;background-color:#1e0010">`</span>Arc<span style="color:#f92672">&lt;</span>AppState<span style="color:#f92672">&gt;</span><span style="color:#960050;background-color:#1e0010">`</span> to implement <span style="color:#960050;background-color:#1e0010">`</span>Send<span style="color:#960050;background-color:#1e0010">`</span>
</span></span><span style="display:flex;"><span>note: <span style="color:#a6e22e">required</span> because it appears within the <span style="color:#66d9ef">type</span> <span style="color:#960050;background-color:#1e0010">`</span>Data<span style="color:#f92672">&lt;</span>AppState<span style="color:#f92672">&gt;</span><span style="color:#960050;background-color:#1e0010">`</span>
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">90</span>  <span style="color:#f92672">|</span> <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Data</span><span style="color:#f92672">&lt;</span>T: <span style="color:#f92672">?</span>Sized<span style="color:#f92672">&gt;</span>(Arc<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span>            <span style="color:#f92672">^^^^</span>
</span></span><span style="display:flex;"><span>note: <span style="color:#a6e22e">required</span> because it<span style="color:#a6e22e">&#39;s</span> used within this closure
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">-</span>-&gt; <span style="color:#a6e22e">src</span><span style="color:#f92672">/</span>lib.rs:<span style="color:#ae81ff">45</span>:<span style="color:#ae81ff">25</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">45</span>  <span style="color:#f92672">|</span>         HttpServer::new(<span style="color:#66d9ef">move</span> <span style="color:#f92672">||</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span>                         <span style="color:#f92672">^^^^^^^</span>
</span></span><span style="display:flex;"><span>note: <span style="color:#a6e22e">required</span> by a bound <span style="color:#66d9ef">in</span> <span style="color:#960050;background-color:#1e0010">`</span>HttpServer::<span style="color:#f92672">&lt;</span>F, I, S, B<span style="color:#f92672">&gt;</span>::new<span style="color:#960050;background-color:#1e0010">`</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">-</span>-&gt; <span style="color:#f92672">/</span>Users<span style="color:#f92672">/</span>marco<span style="color:#f92672">/</span>.cargo<span style="color:#f92672">/</span>registry<span style="color:#f92672">/</span>src<span style="color:#f92672">/</span>index.crates.io<span style="color:#f92672">-</span><span style="color:#ae81ff">6</span>f17d22bba15001f<span style="color:#f92672">/</span>actix<span style="color:#f92672">-</span>web<span style="color:#f92672">-</span><span style="color:#ae81ff">4.5.1</span><span style="color:#f92672">/</span>src<span style="color:#f92672">/</span>server.rs:<span style="color:#ae81ff">94</span>:<span style="color:#ae81ff">20</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">94</span>  <span style="color:#f92672">|</span>     F: Fn() -&gt; <span style="color:#a6e22e">I</span> <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> Clone <span style="color:#f92672">+</span> &#39;static,
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span>                    <span style="color:#f92672">^^^^</span> required by this bound <span style="color:#66d9ef">in</span> <span style="color:#960050;background-color:#1e0010">`</span>HttpServer::<span style="color:#f92672">&lt;</span>F, I, S, B<span style="color:#f92672">&gt;</span>::new<span style="color:#960050;background-color:#1e0010">`</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// same for Sync
</span></span></span></code></pre></div><p>Basically, the compiler is telling us that the policy variable is not safe to move or access among multiple threads:</p>
<ul>
<li><code>Send</code> means a type can be moved/sent to another thread (e.g. when we run the server by spawning the actix http handler)</li>
<li><code>Sync</code>means that the type can be shared and use between threads (e.g. by calling the policy <code>next</code> method from different threads)</li>
</ul>
<p>This is one of the reasons I like rust: the compiler enforces us to use safe abstractions (e.g. forcing my policy to be <code>Sync</code>, a.k.a. thread safe) and explains that clearly in the compilation output!</p>
<h3 id="single-server-policy">Single Server Policy</h3>
<p>To finish our preparatory refactoring, we need to implement a routing policy which allows to always return a single server (the same thing we were doing in Part 1).</p>
<p>Let&rsquo;s implement it and run the tests:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">SingleServerPolicy</span> {
</span></span><span style="display:flex;"><span>	server: String,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> SingleServerPolicy {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(server: String) -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>		Self { server: <span style="color:#a6e22e">server</span> }
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[async_trait]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> RoutingPolicy <span style="color:#66d9ef">for</span> SingleServerPolicy {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">next</span>(<span style="color:#f92672">&amp;</span>self, request: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">HttpRequest</span>) -&gt; String {
</span></span><span style="display:flex;"><span>		self.server.clone()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Notice the use of <code>#[async_trait]</code> here too, as it needs to be applied also to the async trait&rsquo;s implementation.</p>
<p>We can now remove the list of servers from the LoadBalancer struct (and constructor) and move it inside the policy, and we are ready to implement our round robin policy!!</p>
<h3 id="round-robin-policy-test">Round Robin Policy: Test</h3>
<p>The first thing to do is to write another test case for our load balancer, this time spawning multiple upstream servers and checking that they are called in the right order:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[tokio::test]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">test_round_robin_three_servers</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> mocks <span style="color:#f92672">=</span> [
</span></span><span style="display:flex;"><span>		MockServer::start().<span style="color:#66d9ef">await</span>,
</span></span><span style="display:flex;"><span>		MockServer::start().<span style="color:#66d9ef">await</span>,
</span></span><span style="display:flex;"><span>		MockServer::start().<span style="color:#66d9ef">await</span>,
</span></span><span style="display:flex;"><span>	];
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	Mock::given(method(<span style="color:#e6db74">&#34;GET&#34;</span>))
</span></span><span style="display:flex;"><span>	.respond_with(ResponseTemplate::new(<span style="color:#ae81ff">200</span>).set_body_string(<span style="color:#e6db74">&#34;1&#34;</span>))
</span></span><span style="display:flex;"><span>	.mount(<span style="color:#f92672">&amp;</span>mocks[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>	.<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// ... same for mock server 2 and 3, returning a different number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> Client::new();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> mock_uris: Vec<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> mocks.iter().map(<span style="color:#f92672">|</span>mock<span style="color:#f92672">|</span> mock.uri()).collect();
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Spawn load balancer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> policy <span style="color:#f92672">=</span> Box::new(RoundRobinPolicy::new(mock_uris.clone()));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> server <span style="color:#f92672">=</span> LoadBalancer::new(<span style="color:#ae81ff">8082</span>, policy);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> server_uri <span style="color:#f92672">=</span> server.uri();
</span></span><span style="display:flex;"><span>	tokio::spawn(<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> { server.run().<span style="color:#66d9ef">await</span> });
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	wait_server_up(<span style="color:#f92672">&amp;</span>client, <span style="color:#f92672">&amp;</span>server_uri, <span style="color:#ae81ff">3</span>).<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Send requests, expect to respond in round robin (1,2,3,1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> response <span style="color:#f92672">=</span> client.get(<span style="color:#f92672">&amp;</span>server_uri).send().<span style="color:#66d9ef">await</span>.unwrap();
</span></span><span style="display:flex;"><span>	assert_eq!(StatusCode::<span style="color:#66d9ef">OK</span>, response.status());
</span></span><span style="display:flex;"><span>	assert_eq!(<span style="color:#e6db74">&#34;1&#34;</span>, response.text().<span style="color:#66d9ef">await</span>.unwrap());
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> response <span style="color:#f92672">=</span> client.get(<span style="color:#f92672">&amp;</span>server_uri).send().<span style="color:#66d9ef">await</span>.unwrap();
</span></span><span style="display:flex;"><span>	assert_eq!(StatusCode::<span style="color:#66d9ef">OK</span>, response.status());
</span></span><span style="display:flex;"><span>	assert_eq!(<span style="color:#e6db74">&#34;2&#34;</span>, response.text().<span style="color:#66d9ef">await</span>.unwrap());
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> response <span style="color:#f92672">=</span> client.get(<span style="color:#f92672">&amp;</span>server_uri).send().<span style="color:#66d9ef">await</span>.unwrap();
</span></span><span style="display:flex;"><span>	assert_eq!(StatusCode::<span style="color:#66d9ef">OK</span>, response.status());
</span></span><span style="display:flex;"><span>	assert_eq!(<span style="color:#e6db74">&#34;3&#34;</span>, response.text().<span style="color:#66d9ef">await</span>.unwrap());
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> response <span style="color:#f92672">=</span> client.get(<span style="color:#f92672">&amp;</span>server_uri).send().<span style="color:#66d9ef">await</span>.unwrap();
</span></span><span style="display:flex;"><span>	assert_eq!(StatusCode::<span style="color:#66d9ef">OK</span>, response.status());
</span></span><span style="display:flex;"><span>	assert_eq!(<span style="color:#e6db74">&#34;1&#34;</span>, response.text().<span style="color:#66d9ef">await</span>.unwrap());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Right now the test doesn&rsquo;t even compile (we don&rsquo;t have a <code>RoundRobinPolicy</code>struct with a <code>new</code> method).</p>
<p>Let&rsquo;s fix that.</p>
<h3 id="round-robin-policy-implementation">Round Robin Policy: Implementation</h3>
<p>Here is the code for the <code>RoundRobinPolicy</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">RoundRobinPolicy</span> {
</span></span><span style="display:flex;"><span>	servers: Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>	idx: <span style="color:#a6e22e">AtomicUsize</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> RoundRobinPolicy {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(servers: Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>		Self {
</span></span><span style="display:flex;"><span>			idx: <span style="color:#a6e22e">AtomicUsize</span>::new(<span style="color:#ae81ff">0</span>),
</span></span><span style="display:flex;"><span>			servers: <span style="color:#a6e22e">servers</span>.clone(),
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[async_trait]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> RoutingPolicy <span style="color:#66d9ef">for</span> RoundRobinPolicy {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">next</span>(<span style="color:#f92672">&amp;</span>self, _request: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">HttpRequest</span>) -&gt; String {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Read servers list
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">let</span> servers <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>self.servers;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> max_server_idx <span style="color:#f92672">=</span> servers.len() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	  
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Update index
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">let</span> idx <span style="color:#f92672">=</span> self
</span></span><span style="display:flex;"><span>		.idx
</span></span><span style="display:flex;"><span>		.fetch_update(Ordering::Relaxed, Ordering::Relaxed, <span style="color:#f92672">|</span>idx<span style="color:#f92672">|</span> <span style="color:#66d9ef">match</span> idx {
</span></span><span style="display:flex;"><span>			x <span style="color:#66d9ef">if</span> x <span style="color:#f92672">&gt;=</span> max_server_idx <span style="color:#f92672">=&gt;</span> Some(<span style="color:#ae81ff">0</span>),
</span></span><span style="display:flex;"><span>			c <span style="color:#f92672">=&gt;</span> Some(c <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>),
</span></span><span style="display:flex;"><span>		})
</span></span><span style="display:flex;"><span>		.unwrap_or_default();
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Return next server to forward the request to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		servers.get(idx).unwrap().clone()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>On each new request, the policy updates the current upstream server index and returns the corresponding url.</p>
<p>But why is the <code>idx</code> parameter an <code>AtomicUsize</code>? As explained in the <a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicUsize.html"  target="_blank" >documentation</a>, this type allows to safely share the underlying value between threads, as it can be updated atomically. In fact, we update the index with the <code>fetch_update</code> method, which allows to update the number and get the value in a single action, without risking data races and inconsistency when used by multiple threads.</p>
<p>The <code>Ordering:Relaxed</code>params indicate the ordering constraint to be enforced on the atomic operation. I tried to read the <a href="https://doc.rust-lang.org/nomicon/atomics.html"  target="_blank" >book</a> but didn&rsquo;t understand it completely, so refer to that to learn more about this. For now, we&rsquo;re ok using <code>Relaxed</code> (we are updating a counter and nothing more).</p>
<p>Now we have a round robin policy and the test passes. We can also replace the <code>SingleServerPolicy</code> created earlier with our new one and remove that temporary struct used for the refactoring!</p>
<h2 id="conclusions">Conclusions</h2>
<p>This is the end of Part 2. We cleaned up the load balancer code from <a href="https://marcobacis.com/blog/load-balancer-rust-1/"  target="_blank" >Part 1</a>, and added a simple Round-Robin policy to balance the load among multiple upstream servers. The code for this part can be found <a href="https://gist.github.com/marcobacis/477191a3b908c27fd334137cf4b5ee1d"  target="_blank" >here</a>.</p>
<p>Still, the <a href="https://codingchallenges.fyi/challenges/challenge-load-balancer"  target="_blank" >coding challenge</a> is not finished&hellip;.the final step will be to periodically health check the upstream servers, in order to not forward the requests to the unavailable ones.</p>
<p>See you next time for Part 3!</p>
<h2 id="resources">Resources</h2>
<ul>
<li><a href="https://actix.rs/docs"  target="_blank" >Actix Docs</a></li>
<li><a href="https://docs.rs/reqwest/latest/reqwest/"  target="_blank" >Reqwest Docs</a></li>
<li><a href="https://tokio.rs/tokio/tutorial"  target="_blank" >Tokio Tutorial</a></li>
<li><a href="https://doc.rust-lang.org/nomicon/send-and-sync.html"  target="_blank" >Send and Sync</a></li>
<li><a href="https://tontinton.com/posts/scheduling-internals/"  target="_blank" >Scheduling Internals</a> - Tony Solomonik</li>
<li><a href="https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/"  target="_blank" >Why async fn in traits are hard</a> - Niko Matsakis</li>
<li><a href="https://manishearth.github.io/blog/2015/05/27/wrapper-types-in-rust-choosing-your-guarantees/"  target="_blank" >Wrapper Types in Rust: Choosing Your Guarantees</a> - Manish Goregaokar</li>
</ul>

        ]]></content:encoded></item><item><title>Let's build a Load Balancer in Rust - Part 1</title><link>https://marcobacis.com/blog/load-balancer-rust-1/</link><pubDate>Sat, 11 May 2024 00:00:00 +0000</pubDate><guid>https://marcobacis.com/blog/load-balancer-rust-1/</guid><description><p>Hi üëã welcome to a new post!</p><p>This will be the first of a short series of posts, in which I explain my poor attempt at creating a simple HTTP load balancer in Rust.</p></description><media:content url="https://marcobacis.com/blog/load-balancer-rust-1/cover_hu0a658fabcd51b67511a2b4132d0b39d3_85848_480x480_fit_q75_bgffffff_box_3.jpg" width="480" height="480" medium="image" type="image/jpeg"><media:thumbnail url="https://marcobacis.com/blog/load-balancer-rust-1/cover_hu0a658fabcd51b67511a2b4132d0b39d3_85848_480x480_fit_q75_bgffffff_box_3.jpg" width="480" height="480"/></media:content><content:encoded><![CDATA[
        <img src="https://marcobacis.com/blog/load-balancer-rust-1/cover_hu0a658fabcd51b67511a2b4132d0b39d3_85848_480x480_fit_q75_bgffffff_box_3.jpg" title="%!s(<nil>)" alt="%!s(<nil>)"/>
          <p>Hi üëã welcome to a new post!</p>
<p>This will be the first of a short series of posts, in which I explain my poor attempt at creating a simple HTTP load balancer in Rust.</p>
<p>Why a load balancer, and why rust?</p>
<p>I came across this challenge on the <a href="https://codingchallenges.fyi/"  target="_blank" >Coding Challenges</a> newsletter. I had already completed the first challenges (implementing <code>wc</code> and <code>cut</code>), and I thought it was time for a more complex project.</p>
<p>A load balancer provides tons of challenge and can be approached at different levels. From a simple round-robin strategy, to weights, connection pools, asynchronous I/O and much more!</p>
<p>Why Rust? Well, I&rsquo;ve been tinkering with rust for the past year, mostly by solving advent of code problems. It&rsquo;s a high performance, low level language with a mixture of features (e.g. statically typed, not garbage collected, borrow checker, pattern matching and other functional stuff, and zero-cost abstractions) that make it a &ldquo;different&rdquo; language from the ones I usually use at work (C# and a bit of Typescript).</p>
<p>It also sits on a &ldquo;lower&rdquo; level from my usual projects (it&rsquo;s mostly used as a system programming language and in infrastructure), and I think it&rsquo;s cool to learn about the technology which keep my stuff running under the hood!</p>
<p>Also, it&rsquo;s a hyped language üòé, and why shouldn&rsquo;t I try it? Following trends shouldn&rsquo;t always be bad .</p>
<p>A side note: I developed part of the load balancer during the <a href="https://www.meetup.com/it-IT/open-source-saturday-milano/"  target="_blank" >Open Source Saturday Milan</a> meetup, with the help of <a href="https://github.com/MarcoIeni"  target="_blank" >Marco Ieni</a>. Marco is a rust expert and author of many rust crates and projects (e.g. his <a href="https://github.com/MarcoIeni/release-plz"  target="_blank" >release-plz</a> crate, which is fantastic) and he was of great help during the day. Without him, I would have taken a lot more time to setup the project and learn about Arc, Mutex and other async and multithread stuff! Thanks Marco for the help.</p>
<h2 id="load-balancer-basics">Load Balancer basics</h2>
<p>A load balancer is an application which sits in front of a group of servers, and routes the connection/requests across the servers in the group. By routing the requests to multiple backends, it allows to maximise availability (when a server goes down, requests can be redirected to the other servers in the pool) and utilisation (trying to use all servers at their maximum while keeping the latency low).</p>
<p>A load balancer can operate on different levels of the <a href="https://en.wikipedia.org/wiki/OSI_model"  target="_blank" >OSI model</a> (e.g. level 7, the application level, or level 4, the transport layer) with their advantages, disadvantages and numerous nuances.</p>
<p>In my case, the challenge was to create a simple load balancer working at the application level, forwarding HTTP requests. In this first post, we&rsquo;ll see a basic application forwarding HTTP requests to a single server.</p>
<h2 id="project-setup-and-a-first-test">Project setup and a first test</h2>
<p>Let&rsquo;s start the challenge by creating the basic project in rust and writing a simple test. At first I started by coding the simplest application possible without any tests, but Marco showed me how to setup a simple (unit? integration? I  don&rsquo;t know) test for it, so let&rsquo;s do it the proper way üòÖ.</p>
<p><em>Disclaimer: the snippets I post here won&rsquo;t compile most of the time, if you want the complete and updated code (with spoilers) see the <a href="https://github.com/marcobacis/coding-challenges/tree/main/load_balancer"  target="_blank" >repository</a></em></p>
<p>First, let&rsquo;s create the project with cargo:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cargo new lb
</span></span></code></pre></div><p>A common practice is to create a lib inside the crate, in order to extract common behaviour and keep the binary clean. This is a first version of the <code>cargo.toml</code>file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-toml" data-lang="toml"><span style="display:flex;"><span>[<span style="color:#a6e22e">package</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">name</span> = <span style="color:#e6db74">&#34;lb&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">version</span> = <span style="color:#e6db74">&#34;0.1.0&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">edition</span> = <span style="color:#e6db74">&#34;2021&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[<span style="color:#a6e22e">lib</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">name</span> = <span style="color:#e6db74">&#34;lb&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">path</span> = <span style="color:#e6db74">&#34;src/lib.rs&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[[<span style="color:#a6e22e">bin</span>]]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">name</span> = <span style="color:#e6db74">&#34;lb&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">path</span> = <span style="color:#e6db74">&#34;src/bin.rs&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[<span style="color:#a6e22e">dependencies</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">actix-web</span> = <span style="color:#e6db74">&#34;4.5.1&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">clap</span> = <span style="color:#e6db74">&#34;4.5.2&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">reqwest</span> = <span style="color:#e6db74">&#34;0.11.25&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">tokio</span> = { <span style="color:#a6e22e">version</span>=<span style="color:#e6db74">&#34;1.36.0&#34;</span>, <span style="color:#a6e22e">features</span> = [<span style="color:#e6db74">&#34;macros&#34;</span>, <span style="color:#e6db74">&#34;rt-multi-thread&#34;</span>] }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[<span style="color:#a6e22e">dev-dependencies</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">wiremock</span> = <span style="color:#e6db74">&#34;0.6.0&#34;</span>
</span></span></code></pre></div><p>as you can see, right now I&rsquo;m using <code>actix-web</code> as http framework to receive requests, and <code>reqwest</code> to forward them. I decided to not go too deep (managing sockets and http parsing) at the beginning, given that I&rsquo;m not familiar with rust frameworks and libraries yet.</p>
<p>Time for the first test!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[tokio::test]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">test_get_root</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Setup a mock upstream server, to test 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// that the request gets forwarded to it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> mock_server <span style="color:#f92672">=</span> MockServer::start().<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>	Mock::given(method(<span style="color:#e6db74">&#34;GET&#34;</span>))
</span></span><span style="display:flex;"><span>		.respond_with(
</span></span><span style="display:flex;"><span>			ResponseTemplate::new(<span style="color:#ae81ff">200</span>)
</span></span><span style="display:flex;"><span>			.set_body_string(<span style="color:#e6db74">&#34;backend&#34;</span>)
</span></span><span style="display:flex;"><span>		)
</span></span><span style="display:flex;"><span>		.expect(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>		.mount(<span style="color:#f92672">&amp;</span>mock_server)
</span></span><span style="display:flex;"><span>		.<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> Client::new();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// The class under test, the load balancer itself
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> server <span style="color:#f92672">=</span> LoadBalancer::new(<span style="color:#ae81ff">8080</span>, vec![mock_server.uri()]);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> server_uri <span style="color:#f92672">=</span> server.uri();
</span></span><span style="display:flex;"><span>	tokio::spawn(<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> { server.run().<span style="color:#66d9ef">await</span> });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Wait for the server to be up (will fix this later)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	tokio::time::sleep(std::time::Duration::from_secs(<span style="color:#ae81ff">3</span>)).<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Check that we receive response from the mock backend
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// (and not from the load balancer)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> response <span style="color:#f92672">=</span> client.get(server_uri).send().<span style="color:#66d9ef">await</span>.unwrap();
</span></span><span style="display:flex;"><span>	assert_eq!(StatusCode::<span style="color:#66d9ef">OK</span>, response.status());
</span></span><span style="display:flex;"><span>	assert_eq!(<span style="color:#e6db74">&#34;backend&#34;</span>, response.text().<span style="color:#66d9ef">await</span>.unwrap());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In this first step, all we care is that the load balancer is able to forward the request to a single upstream server. We create a mock server (using the <code>wiremock</code>crate, thanks to Marco&rsquo;s advice) to check that the request gets forwarded to it, then instantiate the load balancer and send a simple GET to it.</p>
<p>In pure (A)TDD style, this test doesn&rsquo;t even compile at first. Let&rsquo;s create at least the struct and the method required.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">LoadBalancer</span> {
</span></span><span style="display:flex;"><span>	port: <span style="color:#66d9ef">u16</span>,
</span></span><span style="display:flex;"><span>	servers: Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> LoadBalancer {
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(port: <span style="color:#66d9ef">u16</span>, servers: Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>		LoadBalancer { port, servers }
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">uri</span>(<span style="color:#f92672">&amp;</span>self) -&gt; String {
</span></span><span style="display:flex;"><span>		format!(<span style="color:#e6db74">&#34;http://127.0.0.1:</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, self.port)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">run</span>(<span style="color:#f92672">&amp;</span>self) {}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Obviously, the test is still failing, giving a &ldquo;Connection refused&rdquo; error. We&rsquo;ll get a failing test until the end of this post :P</p>
<h2 id="creating-a-http-forwarder">Creating a HTTP forwarder</h2>
<p>Now, let&rsquo;s open a connection and listen to requests on the port we passed to the load balancer. For now, we&rsquo;ll return a 200 on every request. How can we do it? <a href="https://actix.rs/"  target="_blank" >Actix</a> is a powerful framework for creating web services with rust. It relies on some concepts like extractors and handlers (better explained in their <a href="https://actix.rs/docs/getting-started"  target="_blank" >documentation</a> than here) that allow to easily create http endpoints.</p>
<p>Let&rsquo;s setup a simple server to respond to every request:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> LoadBalancer {
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">/// ... previous methods
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">run</span>(<span style="color:#f92672">&amp;</span>self) {
</span></span><span style="display:flex;"><span>		HttpServer::new(<span style="color:#66d9ef">move</span> <span style="color:#f92672">||</span> App::new()
</span></span><span style="display:flex;"><span>			.default_service(web::to(handler))
</span></span><span style="display:flex;"><span>		)
</span></span><span style="display:flex;"><span>		.bind((<span style="color:#e6db74">&#34;127.0.0.1&#34;</span>, self.port))
</span></span><span style="display:flex;"><span>		.unwrap()
</span></span><span style="display:flex;"><span>		.run()
</span></span><span style="display:flex;"><span>		.<span style="color:#66d9ef">await</span>	
</span></span><span style="display:flex;"><span>		.unwrap();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">handler</span>(req: <span style="color:#a6e22e">HttpRequest</span>) -&gt; <span style="color:#a6e22e">HttpResponse</span> {
</span></span><span style="display:flex;"><span>	HttpResponse::Ok().body(<span style="color:#e6db74">&#34;hello!&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In the <code>run</code> method of our load balancer, we instantiate an Http server which receives any request and returns &ldquo;hello!&rdquo;. The <code>default_service</code> in actix is a catch-all method which receives any request not handled by other services. We use the <code>web::to</code> helper function to create a generic any-method handler (accepting any HTTP method such as GET, POST, PUT etc&hellip;).</p>
<p>Now, let&rsquo;s add some behaviour to the handler. We want it to forward the request to the (only) server we configured in our test. To do so, a first way is to just get the request, copy it and send it to the server, using <code>reqwest</code>. As I already said at the beginning of the post, my goal now is to create a simple proxy, without caring much about performance or functionality.</p>
<p>But how can we use the upstream server url in our request handler? Actix allows to share data between handlers using a concept called <a href="https://actix.rs/docs/application/#shared-mutable-state"  target="_blank" >web::Data</a>. It&rsquo;s a struct encapsulating an <code>Arc</code> (a thread-safe reference counting pointer) in which we can put data that must be shared (immutably or mutably) among handlers and requests.</p>
<p>First, let&rsquo;s define the data we want to share (the servers urls) and add it to the application.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">AppState</span> {
</span></span><span style="display:flex;"><span>	servers: Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">run</span>(<span style="color:#f92672">&amp;</span>self) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> data <span style="color:#f92672">=</span> web::Data::new(AppState {
</span></span><span style="display:flex;"><span>		servers: <span style="color:#a6e22e">self</span>.servers.clone(),
</span></span><span style="display:flex;"><span>	});
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	HttpServer::new(<span style="color:#66d9ef">move</span> <span style="color:#f92672">||</span> {
</span></span><span style="display:flex;"><span>		App::new()
</span></span><span style="display:flex;"><span>			.default_service(web::to(Self::handler))
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// We add the initial instance of our shared app state
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			.app_data(data.clone())
</span></span><span style="display:flex;"><span>	})
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// as above, bind and run ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>})
</span></span></code></pre></div><p>Then, we can use the shared data inside the handler using an <a href="https://actix.rs/docs/extractors"  target="_blank" >extractor</a>, a parameter used in the function to access parts of the request, or the application state in this case:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">handler</span>(req: <span style="color:#a6e22e">HttpRequest</span>, data: <span style="color:#a6e22e">web</span>::Data<span style="color:#f92672">&lt;</span>AppState<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">HttpResponse</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> server <span style="color:#f92672">=</span> data.servers[<span style="color:#ae81ff">0</span>].clone();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// do stuff with server url now
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	HttpResponse::Ok().body(<span style="color:#e6db74">&#34;hello&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Finally, it&rsquo;s time to forward the request! The code below is not so performant (it instantiates a reqwest client on every request, clones the headers betweeen the input and forwarded request, and so on..), but it works:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">handler</span>(
</span></span><span style="display:flex;"><span>	req: <span style="color:#a6e22e">HttpRequest</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Extractor used to get the shared application state
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	data: <span style="color:#a6e22e">web</span>::Data<span style="color:#f92672">&lt;</span>AppState<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Extractor used to get the request payload as raw bytes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	bytes: <span style="color:#a6e22e">web</span>::Bytes,
</span></span><span style="display:flex;"><span>) -&gt; Result<span style="color:#f92672">&lt;</span>HttpResponse, Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Get the address to which to forward the request
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> server <span style="color:#f92672">=</span> data.servers[<span style="color:#ae81ff">0</span>].clone();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> uri <span style="color:#f92672">=</span> format!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}{}</span><span style="color:#e6db74">&#34;</span>, server, req.uri());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Create the request
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> Client::new();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> request_builder <span style="color:#f92672">=</span> client
</span></span><span style="display:flex;"><span>		.request(req.method().clone(), uri)
</span></span><span style="display:flex;"><span>		.headers(req.headers().into())
</span></span><span style="display:flex;"><span>		.body(bytes);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Forward the request
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> response <span style="color:#f92672">=</span> request_builder.send().<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Get the response and send it back to the client
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> response_builder <span style="color:#f92672">=</span> HttpResponse::build(response.status());
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> h <span style="color:#66d9ef">in</span> response.headers().iter() {
</span></span><span style="display:flex;"><span>		response_builder.append_header(h);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> body <span style="color:#f92672">=</span> response.bytes().<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	Ok(response_builder.body(body))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>After this, the test passes, and we&rsquo;re all set! I left out the implementation of the <code>Error</code>  struct (it takes the <code>reqwest::Error</code> and stores it inside the struct, along with the implementation of the <code>From&lt;reqwest::Error&gt;</code> and <code>ResponseError</code> traits).</p>
<p>You can find the code of this simple HTTP forwarder <a href="https://gist.github.com/marcobacis/4ba9d0885862239d9ed7482983047472"  target="_blank" >here</a>. Also, I keep a repository to all the solutions I came up for coding challenges, <a href="https://github.com/marcobacis/coding-challenges"  target="_blank" >here</a>.</p>
<p>See you next time for part 2, in which we add a simple round-robin policy and transform our simple Proxy in a real (almost) LoadBalancer!</p>
<h2 id="resources">Resources</h2>
<ul>
<li><a href="https://actix.rs/docs"  target="_blank" >Actix Docs</a></li>
<li><a href="https://docs.rs/reqwest/latest/reqwest/"  target="_blank" >Reqwest Docs</a></li>
<li><a href="https://codingchallenges.fyi/"  target="_blank" >Coding Challenges Website</a></li>
<li><a href="https://www.nginx.com/resources/glossary/load-balancing/"  target="_blank" >What is Load Balancing?</a></li>
</ul>
        ]]></content:encoded></item></channel></rss>