<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>backend on Marco Bacis</title><link>http://marcobacis.com/tags/backend/</link><description>Recent content in backend on Marco Bacis</description><language>en-uk</language><copyright>Â© Copyright Marco Bacis 2018-2023</copyright><lastBuildDate>Sun, 02 Jul 2023 18:00:00 +0100</lastBuildDate><atom:link href="http://marcobacis.com/tags/backend/index.xml" rel="self" type="application/rss+xml"/><item><title>Working Software Conference 2023</title><link>http://marcobacis.com/blog/working-software-2023/</link><pubDate>Sun, 02 Jul 2023 18:00:00 +0100</pubDate><guid>http://marcobacis.com/blog/working-software-2023/</guid><description>&lt;p>Hi ðŸ‘‹Â and welcome to a new post!&lt;/p>
&lt;p>Last Friday I attended the 2023 &lt;a href="https://www.agilemovement.it/workingsoftware/">Working Software Conference&lt;/a> in Milan. The Working Software Conference is an event organised by the &lt;a href="https://agilemovement.it">Italian Agile Movement&lt;/a>, focused on the second principle of the &lt;a href="https://agilemanifesto.org">agile manifesto&lt;/a>:&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>Working software over comprehensive documentation&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>The meaning of this principle is that we should focus on delivering value (the working software) to the user instead of writing extensive specification documents (a.k.a. â€œwasting timeâ€, as all the requirements and documentation will need to be adapted to change in a very short time).&lt;/p>
&lt;p>The conference contained a mixture of front sessions and workshops.
In particular, I attended two workshops, one in the morning and one in the afternoon. In this post I present a small summary and comment of the two workshops, with some considerations at the end.&lt;/p>
&lt;p>Enjoy!&lt;/p>
&lt;h3 id="affoghiamo-i-microservizi-nella-birra---christian-de-simone-and-alberto-acerbis">â€œAffoghiamo i microservizi nella birraâ€ - Christian De Simone and Alberto Acerbis&lt;/h3>
&lt;p>&lt;em>â€œLetâ€™s drown microservices in beerâ€&lt;/em>&lt;/p>
&lt;p>The first workshop I attended was held by &lt;a href="https://www.linkedin.com/in/aacerbis/">Alberto Acerbis&lt;/a> and &lt;a href="https://www.linkedin.com/in/desimonechristian/">Christian De Simone&lt;/a>, and was about how a monolith can deliver value to the customer in a fast way, and without compromising its future extension and scalability.&lt;/p>
&lt;p>The first part was a small exercise: we had to design and start implementing a couple of services (purchases and warehouse) for a small brewery. We divided in groups, and in my team we immediately started splitting the two domains in separate micro services communicating with an external broker. We hadnâ€™t even started to implement the system (just coded the first purchases endpoint) that it was time for a discussion with the other teams.&lt;/p>
&lt;p>Every team used a different approach: serverless, microservices, monolith and so onâ€¦. in the end, Alberto and Christian discussed the different pros and cons of our solutions, and then presented a way to deliver value to the customer without creating unneeded complexity and costs: a &lt;strong>Modular Monolith&lt;/strong>.&lt;/p>
&lt;p>Alberto showed an example &lt;a href="https://github.com/BrewUp/WorkingSoftware-2023">solution&lt;/a>, with the two different domains implemented as projects inside the same solution. Every domain was separated from the other (and the separation checked with &lt;a href="https://archunitnet.readthedocs.io/en/latest/">ArchUnit&lt;/a> tests) and communicated with a common broker implemented with the &lt;a href="https://github.com/jbogard/MediatR">MediatR&lt;/a> library. This kind of architecture has the pros of both monolith (fast iterations for a small team and small product) and modular and event-based applications, allowing further extensibility in the future, &lt;strong>if&lt;/strong> and when the business will grow.&lt;/p>
&lt;p>After seeing the implementation of a modular monolith, a question remained: how do we deploy it? And how do we keep costs to a minimum doing it? Different solutions exist:&lt;/p>
&lt;ul>
&lt;li>Monolith executable deployed on a VM&lt;/li>
&lt;li>Docker container deployed using docker compose or k8s&lt;/li>
&lt;li>Serverless solutions such as container-as-a-service or function-as-a-service&lt;/li>
&lt;/ul>
&lt;p>Christian showed us a possible solution: given that the first implementation of the system is a simple monolith, itâ€™s possible to keep costs low by taking advantage of managed serverless solutions, and using docker allows to still be prepared for future extensions to the system (e.g. in a Kubernetes cluster).&lt;/p>
&lt;p>Our task for the second half of the workshop was to â€œdockerizeâ€ the simple endpoint we developer earlier and push it to a GitHub repository. He then showed us a way of deploying docker containers in production, by using a managed service offered by &lt;a href="https://www.scaleway.com/en/serverless-containers/">scaleway&lt;/a>.&lt;/p>
&lt;p>Finally, it was time to show off how we could deploy to Kubernetes, in case our brewery would grow a lot!! Christian set up a small Kubernetes cluster (always on scaleway) in which to deploy our services when they were pushed on a GitHub repository. He also explained a useful tool for deploying on Kubernetes, called &lt;a href="https://helm.sh">helm&lt;/a>, which allows to define â€œchartsâ€ (parametrised templates of k8s resources and deployments) that can be deployed as a single unit. Helm is useful both for our projects and to deploy external dependencies (he deployed a MongoDb instance with a click).&lt;/p>
&lt;p>Alberto and Christian explained the Modular monolith concept in a easily understandable way, and we were able to gain some concepts and understand the pros and cons of it. In addition, the live code explanation and live deploy to Kubernetes were amazing ðŸ˜ƒ. I also discovered some tools (MediatR, ArchUnit and helm) that I didnâ€™t know yet, and will try for sure in my projects!&lt;/p>
&lt;h3 id="faccio-prima-il-refactor-o-i-tests---gianni-bombelli">â€œFaccio prima il refactor o i tests?â€ - Gianni Bombelli&lt;/h3>
&lt;p>&lt;em>â€œShould I do refactoring or tests first?â€&lt;/em>&lt;/p>
&lt;p>In the afternoon, I participated in a workshop held by &lt;a href="https://www.linkedin.com/in/gianni-bombelli/">Gianni Bombelli&lt;/a> and focused on testing and refactoring a (small) piece of legacy code.&lt;/p>
&lt;p>We started the workshop with a great ice breaker: Gianni gave us a roll of toilet paper and asked each participant to draw as much paper as we usually useâ€¦. then, for each square of paper, each one had to say something about him/herself. Even before coding, I learned something ðŸ˜‚Â to use less paperâ€¦&lt;/p>
&lt;p>The workshop exercise was to work in pairs, testing and refactoring a small piece of code (you can find it already solved by Gianni in his &lt;a href="https://github.com/bombo82/workshop-ws-2023">repository&lt;/a>) themed around the â€œAnother brick in the wallâ€ song by Pink Floyd (obviously, Gianni was wearing a â€œThe Wallâ€ t-shirt ðŸ˜ƒ). I paired with Christian (from the morning workshop, see above) we started to write a small test for the already implemented method we found in the repo, andâ€¦.. it threw a â€œNotTestableCallExceptionâ€!&lt;/p>
&lt;p>Some quick notes about the exercise:&lt;/p>
&lt;ul>
&lt;li>We couldnâ€™t use external dependencies and libraries&lt;/li>
&lt;li>No Mocks&lt;/li>
&lt;li>The code worked in production, even if we encountered difficulties in testing it! So, we should have touched it with care&lt;/li>
&lt;/ul>
&lt;p>The exception we found was a simple example of what we could find in real production code: a static method to get the logged in user (e.g. taken from spring or from .NET authentication modules), which would work when deployed but not on our local setup.&lt;/p>
&lt;p>To continue testing this code we should have removed the exception. But how to remove it without changing the production code and without testing it first? How could we test without refactoring first, and refactor without tests?&lt;/p>
&lt;p>Gianni solved this dilemma for us: we could leverage some minimal and automated refactoring (available in most IDEs) to â€œcleanâ€ the code enough to write some tests. In our case, this meant extracting the untestable method in a separate method, and extending the class under test to override the extracted method!&lt;/p>
&lt;p>Using an overridden method in a class used only for testing is similar to mocks and stubs, but in this case the â€œtrickâ€ (and the smell) was quite visible (in the tested and the test classes) as a remainder for us to clean this code afterwards.&lt;/p>
&lt;p>We used this method for most of the workshop, extracting problematic code from the tested method and using this for our purposes. In particular, we focused on:&lt;/p>
&lt;ul>
&lt;li>Static/Singleton objects and methods out of our control&lt;/li>
&lt;li>System calls (e.g. the use of DateTime.Now for equality)&lt;/li>
&lt;li>Possibile side effects given by external dependencies&lt;/li>
&lt;/ul>
&lt;p>After covering all the code with tests, we were finally able to refactor it easily. We tried by ping-ponging refactoring pieces of code between me and Christian, and finished in no time!&lt;/p>
&lt;p>A last issue we encountered was how to refactor a possible side effect given by the use of a DAO (Data Access Object). Gianni helped us by explaining that in these cases, the issue can be solved with an in-memory structure to mimic the underlying object without using the real dependency.&lt;/p>
&lt;p>In the end, we finally refactored the code to our liking, and ended up the workshop with a discussion on what we had learned.&lt;/p>
&lt;p>So, what comes first, refactoring or testing? Here&amp;rsquo;s the solution: first, apply the minimum set of â€œsafeâ€ refactoring to make the code testable. Then, cover the code with tests. Only after that you can refactor the code â€œproperlyâ€! In most cases it will be an iterative process of refactor â†’ test â†’ refactor.&lt;/p>
&lt;p>Gianni was a great instructor. He let us bang our heads against the code, and only after he showed us how to work with it. His explanations were on point and, most of all, he encouraged us to discuss with him and the other pairs. I learned some neat tricks to work with untested (and untestable) code and it was great!&lt;/p>
&lt;h2 id="the-end">The End!&lt;/h2>
&lt;p>The Working Software Conference was a great event to meet new people and learn new technologies and ways to work as a software developer. I only attended two workshops, but I would have wanted it to go on for way more than a single day! All the instructors were prepared and engaging, and I learned a lot during the day. I hope to attend other events like this in the near future!&lt;/p>
&lt;p>That&amp;rsquo;s all for today. Thanks, and see you next time! ðŸ‘‹&lt;/p>
&lt;p>PS. At the end of the conference there were some prizes, and I won a curved monitorâ€¦ a great ending for an already great day ðŸ˜„. Thanks to &lt;a href="https://www.intre.it">IntrÃ¨&lt;/a> for the monitor, and all the other sponsors, organizers and participants for the great conference!&lt;/p>
&lt;p>
&lt;img class="img-fluid image" src="new_setup.png" alt="My new setup after the conference" />
&lt;/p></description></item><item><title>XPUGBg March Meetup: â€œThe Actor Model (and why an XP programmer should know it)â€œ</title><link>http://marcobacis.com/blog/2023-actor-model-meetup/</link><pubDate>Sat, 01 Apr 2023 08:00:00 +0100</pubDate><guid>http://marcobacis.com/blog/2023-actor-model-meetup/</guid><description>&lt;p>Hi ðŸ‘‹ welcome!&lt;/p>
&lt;p>This post is a short summary (with personal notes and opinions here and there) of the XPUGBg (Bergamoâ€™s eXtreme Programming User Group) meetup I attended in March.&lt;/p>
&lt;p>Actually, itâ€™s just a bunch of notes and ideas connected together by my imagination and opinions ðŸ˜‚ (as I already did &lt;a href="http://marcobacis.com/blog/2022-dec-mars-rover-kata-meetup/">here&lt;/a> and &lt;a href="http://marcobacis.com/blog/2023-jan-xp-codebase-meetup/">here&lt;/a>).&lt;/p>
&lt;p>This month&amp;rsquo;s talk was titled â€œ&lt;em>The Actor Model and why an XP programmer should know it&lt;/em>â€ by Emanuele DelBono.&lt;/p>
&lt;p>Emanuele is a Software Architect and Developer at &lt;a href="https://codiceplastico.com/">Codice Plastico&lt;/a>, a software house near Brescia. He has a lot of experience and heâ€™s always interested in experimenting with new paradigms and technologies, and right now heâ€™s working with Elixir (the language he used during the talk).&lt;/p>
&lt;p>Letâ€™s start!&lt;/p>
&lt;h2 id="the-actor-model">The Actor Model&lt;/h2>
&lt;p>The Actor Model is a programming paradigm for concurrent and parallel computations. In this model, all computation is divided into different components called Actors.&lt;/p>
&lt;p>An &lt;strong>Actor&lt;/strong> is an individual unit of computation with its private state. A single actor by itself cannot do much but must work in a system of multiple, &lt;strong>independent&lt;/strong> actors.&lt;/p>
&lt;p>Multiple actors together can be used to perform any computation, but only if they communicate! This is done by assigning a unique &lt;strong>address&lt;/strong> to each one and using messages. Each actor can receive and send messages from/to others.&lt;/p>
&lt;p>One key difference between the Actor Model and any other event/message-based system is that an actor can process only &lt;strong>one message at a time&lt;/strong>. This is a big constraint imposed by the model, but it makes the actorâ€™s computation model simple to reason about. By processing one message at a time, it basically eliminates any chance of data race inside the single unit. In addition, it makes the code easily testable (send a message and check the output message and created actors; thatâ€™s it!).&lt;/p>
&lt;p>The final action that an actor can do, apart from receiving and sending messages, is to create other actors.&lt;/p>
&lt;p>The model just described is really similar to standard OOP. In fact, it fits perfectly with the definition given by Alan Kay, which is of multiple independent objects communicating with messages.&lt;/p>
&lt;h3 id="pros-cons-and-use-cases">Pros, Cons, and Use Cases&lt;/h3>
&lt;p>So, how can this paradigm be useful to us developers?&lt;/p>
&lt;p>The first advantage of the Actor Model is the strong &lt;strong>decoupling&lt;/strong> and &lt;strong>isolation&lt;/strong> of state between different Actors. The Actors can only communicate using messages, so no one can access an Actorâ€™s individual state.&lt;/p>
&lt;p>Another pro of Actors is their extreme scalability. Depending on the Actorâ€™s granularity (the size of each actor), there might be hundreds or even thousands of Actors at the same time in the system. Being decoupled and isolated among themselves, itâ€™s possible to distribute the computation and the state among multiple nodes easily. This is also helped by frameworks, which handle the redistribution of Actors in the cluster automatically.&lt;/p>
&lt;p>Finally, the model helps in reducing the cognitive load of the developer. By processing only one message at a time and communicating only through messages, the developer doesnâ€™t need to think about nasty side effects or multi-object state changes. There might be a steeper learning curve at the beginning, as always when creating distributed systems, but the model helps in making it easier in the long run.&lt;/p>
&lt;h3 id="actor-model-implementations">Actor Model Implementations&lt;/h3>
&lt;p>After describing the actor model in theory, Emanuele showed us different languages that implement this paradigm. Some of the technologies are Erlang, Elixir, Akka (a framework used in the JVM and .NET ecosystems), Swift, and Pony.&lt;/p>
&lt;p>One of the first languages to use a similar paradigm to the Actor Model is Erlang. Erlang was created in the 90s at Ericsson, and at the beginning, it was used to manage their telecommunications infrastructure (telephone switches). The main requirements it served were to allow concurrent computation, allow hot-reloading of components, and robust failure management.&lt;/p>
&lt;p>Erlang supports all these scenarios by implementing a paradigm very similar to the Actor Model. The only differences are in the messaging order (incoming messages are ordered, while the Actor Model doesnâ€™t require it) and the absence of exception management.&lt;/p>
&lt;p>This last characteristic is known as â€œlet it failâ€: when an actor has an error, we donâ€™t throw an exception, but we just let it crash and create a new one. The mechanism is a precursor to the current cloud paradigm, in which small individual components can crash and be recreated immediately (think of k8s and docker containers).&lt;/p>
&lt;p>Elixir is the successor of Erlang, as it runs on the same virtual machine (BEAM), implements the actor model in the Erlang way, and is also functional. Emanuele used it for the demo.&lt;/p>
&lt;h3 id="demo-pizza-ordering-api-with-actors">Demo: Pizza ordering API with Actors&lt;/h3>
&lt;p>Emanuele used Elixir to show us a small demo of an actor-based web service for a pizza delivery service.&lt;/p>
&lt;p>The service was pretty simple, with a web API for managing the basket, time slots, and orders from the customer and the pizzeria sides.&lt;/p>
&lt;p>Some considerations about the demo and the model in general:&lt;/p>
&lt;ul>
&lt;li>Elixir is functional, so the internal actor state is managed with immutable and pure functions (similar to reducers)&lt;/li>
&lt;li>We can create a lot of actors!! The demo created an actor for each user (for the basket), for each time slot (and there can be thousands of them in a year) and for each created order. They almost felt as standard objects, but all kept at runtime&lt;/li>
&lt;li>Some actors (like the ones managing the basket) didnâ€™t save the state in persistent storage. This was an architectural choice made based on the use case (if a basket actor fails, we just lose the current basket, nothing special)&lt;/li>
&lt;li>Elixir allows both synchronous and asynchronous sending of messages and to respond to messages (e.g., to return errors to clients in the http endpoints)&lt;/li>
&lt;/ul>
&lt;h3 id="conclusions">Conclusions&lt;/h3>
&lt;p>The meetup was really interesting. I already knew about the Actor Model (I studied a bit of Scala while in university), but this talk was a refresher on the concepts and actually showed a production-like example of how working with Actors feels.&lt;/p>
&lt;p>I think the Actor Model paved the way for current technologies (microservices and containers) and that its philosophy is hidden in many current languages, so itâ€™s an important paradigm to study. Also, itâ€™s a great way to learn to divide a system into decoupled components, which fits well with other architectural practices (Domain-Driven Design, Event Sourcing, CQRS, and many other buzzwords) and with good software in general.&lt;/p>
&lt;p>Thatâ€™s it for today. I hope my short summary of Emanueleâ€™s talk intrigued you, and that right now youâ€™ll go watch his other talk (link right below here) and start learning the Actor Model!&lt;/p>
&lt;p>As always, thanks to the &lt;a href="https://www.meetup.com/it-IT/xpugbg/">XPUGBg&lt;/a> and to &lt;a href="https://www.linkedin.com/in/emanueledb/">Emanuele&lt;/a> for the great meetup (and the pub after that ðŸ˜‰).&lt;/p>
&lt;p>See you next time!&lt;/p>
&lt;h3 id="resources">Resources&lt;/h3>
&lt;ul>
&lt;li>Another &lt;a href="https://blog.codiceplastico.com/events/avanscoperta-introduzione-actor-model">talk&lt;/a> given by Emanuele&lt;/li>
&lt;li>The &lt;a href="https://www.amazon.it/Cronache-Domain-Driven-esperienze-progetti-raccontati/dp/8894255697/">Cronache di Domain-Driven Design&lt;/a> book has a chapter by Emanuele on using DDD and Actors in a real-life scenario (which inspired the Talk and Demo ðŸ˜›)&lt;/li>
&lt;/ul></description></item></channel></rss>