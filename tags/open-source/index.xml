<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>Open Source on Marco Bacis</title><link>https://marcobacis.com/tags/open-source/</link><description>Recent content in Open Source on Marco Bacis</description><language>en-uk</language><copyright>© Copyright Marco Bacis 2018-2024</copyright><lastBuildDate>Sun, 02 Jun 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://marcobacis.com/tags/open-source/index.xml" rel="self" type="application/rss+xml"/><item><title>Let's build a Load Balancer in Rust - Part 3</title><link>https://marcobacis.com/blog/load-balancer-rust-3/</link><pubDate>Sun, 02 Jun 2024 00:00:00 +0000</pubDate><guid>https://marcobacis.com/blog/load-balancer-rust-3/</guid><description>Third and last part of the &ldquo;Build your own load balancer in rust&rdquo; series! In this last part, we implement a healthcheck procedure to avoid forwarding requests to unavailable nodes.</description><media:content url="https://marcobacis.com/blog/load-balancer-rust-3/cover_hu12279451129204478593.jpg" width="480" height="480" medium="image" type="image/jpeg"><media:thumbnail url="https://marcobacis.com/blog/load-balancer-rust-3/cover_hu12279451129204478593.jpg" width="480" height="480"/></media:content><content:encoded><![CDATA[
        <img src="https://marcobacis.com/blog/load-balancer-rust-3/cover_hu12279451129204478593.jpg" title="%!s(<nil>)" alt="%!s(<nil>)"/>
          




    <hr/>
    <div class="series-list">
        <h3>"Build your own load balancer in Rust" series</h3>
        <ul>
            
                <li>
                    
                        <a href="/blog/load-balancer-rust-1">Part 1: Setup and http forwarding</a>
                    
                </li>
            
                <li>
                    
                        <a href="/blog/load-balancer-rust-2">Part 2: Round-Robin Policy</a>
                    
                </li>
            
                <li>
                    
                        Part 3: Healthcheck
                    
                </li>
            
        </ul>
        <hr/>
    </div>

<p>Hi  👋 welcome to a new post!</p>
<p>This is the third (and last?) part of the series &ldquo;let&rsquo;s build a load balancer in rust&rdquo;.</p>
<p>In the <a href="https://marcobacis.com/blog/load-balancer-rust-1/"  target="_blank" >first post</a> we saw how to forward a single request to an upstream server, using <a href="https://actix.rs/"  target="_blank" >Actix</a> and <a href="https://docs.rs/reqwest/latest/reqwest/"  target="_blank" >Reqwest</a>. Then, we implemented a simple round-robin strategy in the <a href="https://marcobacis.com/blog/load-balancer-rust-2/"  target="_blank" >second post</a> .</p>
<p>In this last part, we are going to integrate a simple health check into our load balancer, to avoid sending requests to unavailable upstream servers!</p>
<h2 id="simplifying-the-round-robin-policy">Simplifying the Round-Robin policy</h2>
<p>As already done in part 2, let&rsquo;s start with some small chores in our code from the previous post. I hope this shows that even when writing and being careful during development, there&rsquo;s always room for improvement.</p>
<p>The small refactoring we are going to do is related to the round-robin policy code, in particular how we increment the counter. In the previous post, I implemented the policy update in this way:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">next</span>(<span style="color:#f92672">&amp;</span>self, _request: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">HttpRequest</span>) -&gt; String {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Read servers list
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> servers <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>self.servers;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> max_server_idx <span style="color:#f92672">=</span> servers.len() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Update index
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> idx <span style="color:#f92672">=</span> self
</span></span><span style="display:flex;"><span>	.idx
</span></span><span style="display:flex;"><span>	.fetch_update(Ordering::Relaxed, Ordering::Relaxed, <span style="color:#f92672">|</span>idx<span style="color:#f92672">|</span> <span style="color:#66d9ef">match</span> idx {
</span></span><span style="display:flex;"><span>		x <span style="color:#66d9ef">if</span> x <span style="color:#f92672">&gt;=</span> max_server_idx <span style="color:#f92672">=&gt;</span> Some(<span style="color:#ae81ff">0</span>),
</span></span><span style="display:flex;"><span>		c <span style="color:#f92672">=&gt;</span> Some(c <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>),
</span></span><span style="display:flex;"><span>	})
</span></span><span style="display:flex;"><span>	.unwrap_or_default();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Return next server to forward the request to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	servers.get(idx).unwrap().clone()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The code is complex, requires to know about atomics, the <code>fetch_update</code> method and has two different <code>Ordering</code> parameters. We can make it simpler, by using a simple <code>fetch_add</code> and using the modulo operator to stay between 0 and the number of available backends:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">next</span>(<span style="color:#f92672">&amp;</span>self, _request: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">HttpRequest</span>) -&gt; String {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> idx <span style="color:#f92672">=</span> self.idx.fetch_add(<span style="color:#ae81ff">1</span>, Ordering::Relaxed);
</span></span><span style="display:flex;"><span>	self.servers.get(idx <span style="color:#f92672">%</span> self.servers.len()).unwrap().clone()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>fetch_add</code> method allows to increment an <code>AtomicUsize</code> value in an atomic way, but it&rsquo;s simpler than the <code>fetch_update</code> used earlier (e.g. has only 1 ordering parameter and directly returns the new value without a possible <code>None</code>).</p>
<h2 id="introducing-our-load-balancer-configuration">Introducing our Load Balancer configuration</h2>
<p>Up till now, we have used a <code>Vec&lt;String&gt;</code> to represent the load balancer configuration. It&rsquo;s now time to introduce some new parameters, and to wrap our simple string in a more suitable <code>struct</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Backend</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> url: String,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> healthcheck_path: String,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Config</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> backends: Vec<span style="color:#f92672">&lt;</span>Backend<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> health_check_interval_secs: <span style="color:#66d9ef">usize</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Each backend now has the url (host) and a path through which the load balancer can check the health of the upstream server. If the given endpoint doesn&rsquo;t respond or returns an error, the corresponding upstream server will be considered unavailable.</p>
<p>The other parameter we introduce is a simple interval (in seconds) after which we should check the availability of the upstream servers. We will use it later.</p>
<h2 id="acceptance-test">Acceptance Test</h2>
<p>It&rsquo;s now time to finally start implementing our healthcheck! As always, let&rsquo;s start with a (failing) acceptance test:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[tokio::test]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">test_health_check_simple</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> mocks <span style="color:#f92672">=</span> create_mocks(<span style="color:#ae81ff">2</span>).<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Mock 1 answers on all paths
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	Mock::given(method(<span style="color:#e6db74">&#34;GET&#34;</span>))
</span></span><span style="display:flex;"><span>		.respond_with(
</span></span><span style="display:flex;"><span>			ResponseTemplate::new(<span style="color:#ae81ff">200</span>).set_body_string(<span style="color:#e6db74">&#34;1&#34;</span>)
</span></span><span style="display:flex;"><span>		)
</span></span><span style="display:flex;"><span>		.mount(<span style="color:#f92672">&amp;</span>mocks[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>		.<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Mock 2 answers only on /, not on /health
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	Mock::given(method(<span style="color:#e6db74">&#34;GET&#34;</span>))
</span></span><span style="display:flex;"><span>		.and(path(<span style="color:#e6db74">&#39;/&#39;</span>))
</span></span><span style="display:flex;"><span>		.respond_with(
</span></span><span style="display:flex;"><span>			ResponseTemplate::new(<span style="color:#ae81ff">200</span>).set_body_string(<span style="color:#e6db74">&#34;2&#34;</span>)
</span></span><span style="display:flex;"><span>		)
</span></span><span style="display:flex;"><span>		.mount(<span style="color:#f92672">&amp;</span>mocks[<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>		.<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Start server
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> config <span style="color:#f92672">=</span> build_config(<span style="color:#f92672">&amp;</span>mocks);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> policy <span style="color:#f92672">=</span> Box::new(RoundRobinPolicy::new(<span style="color:#f92672">&amp;</span>config));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> server <span style="color:#f92672">=</span> LoadBalancer::new(<span style="color:#ae81ff">8082</span>, <span style="color:#f92672">&amp;</span>config, policy);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> server_uri <span style="color:#f92672">=</span> server.uri();
</span></span><span style="display:flex;"><span>	tokio::spawn(<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> { server.run().<span style="color:#66d9ef">await</span> });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> ClientBuilder::new()
</span></span><span style="display:flex;"><span>		.timeout(Duration::from_secs(<span style="color:#ae81ff">2</span>))
</span></span><span style="display:flex;"><span>		.build()
</span></span><span style="display:flex;"><span>		.unwrap();
</span></span><span style="display:flex;"><span>	wait_server_up(<span style="color:#f92672">&amp;</span>client, <span style="color:#f92672">&amp;</span>server_uri, <span style="color:#ae81ff">3</span>).<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Expect only mock[1] to respond to 2 consecutive requests
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> response <span style="color:#f92672">=</span> client.get(<span style="color:#f92672">&amp;</span>server_uri).send().<span style="color:#66d9ef">await</span>.unwrap();
</span></span><span style="display:flex;"><span>	assert_eq!(StatusCode::<span style="color:#66d9ef">OK</span>, response.status());
</span></span><span style="display:flex;"><span>	assert_eq!(<span style="color:#e6db74">&#34;1&#34;</span>, response.text().<span style="color:#66d9ef">await</span>.unwrap());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> response <span style="color:#f92672">=</span> client.get(<span style="color:#f92672">&amp;</span>server_uri).send().<span style="color:#66d9ef">await</span>.unwrap();
</span></span><span style="display:flex;"><span>	assert_eq!(StatusCode::<span style="color:#66d9ef">OK</span>, response.status());
</span></span><span style="display:flex;"><span>	assert_eq!(<span style="color:#e6db74">&#34;1&#34;</span>, response.text().<span style="color:#66d9ef">await</span>.unwrap());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In the test, we are setting up two mock servers. The first one responds on every path, while the second doesn&rsquo;t respond on the <code>/health</code> endpoint that we expect for health monitoring.
We expect the load balancer to forward requests only to the &ldquo;healthy&rdquo; upstream server, which responds with &ldquo;1&rdquo;.</p>
<h2 id="implementing-the-health-check-procedure">Implementing the Health Check procedure</h2>
<p>The healthcheck implementation will be split in 3 parts:</p>
<ul>
<li>Checking the health of all the upstream servers periodically</li>
<li>Adding the health check results to the round-robin policy</li>
<li>Integrating the two parts together</li>
</ul>
<p>Let&rsquo;s start by checking which servers are available:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">HealthResult</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> backend: <span style="color:#a6e22e">Backend</span>,
</span></span><span style="display:flex;"><span>    healthy: <span style="color:#66d9ef">bool</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_healthy_backends</span>(client: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Client</span>, backends: <span style="color:#66d9ef">&amp;</span>Vec<span style="color:#f92672">&lt;</span>Backend<span style="color:#f92672">&gt;</span>) -&gt; Vec<span style="color:#f92672">&lt;</span>HealthResult<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Check all backends for the health endpoint
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> results <span style="color:#f92672">=</span> join_all(backends.iter().map(<span style="color:#f92672">|</span>b<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>        client
</span></span><span style="display:flex;"><span>            .get(format!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}{}</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>b.url, <span style="color:#f92672">&amp;</span>b.healthcheck_path))
</span></span><span style="display:flex;"><span>            .send()
</span></span><span style="display:flex;"><span>    }))
</span></span><span style="display:flex;"><span>    .<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Map responses to simple boolean to match to backends
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> results <span style="color:#f92672">=</span> results.iter().map(<span style="color:#f92672">|</span>res<span style="color:#f92672">|</span> <span style="color:#66d9ef">match</span> res {
</span></span><span style="display:flex;"><span>        Ok(response) <span style="color:#f92672">=&gt;</span> response.status().is_success(),
</span></span><span style="display:flex;"><span>        Err(_) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">false</span>,
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Match result and backend together
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    zip(backends, results)
</span></span><span style="display:flex;"><span>        .map(<span style="color:#f92672">|</span>(backend, healthy)<span style="color:#f92672">|</span> HealthResult {
</span></span><span style="display:flex;"><span>            backend: <span style="color:#a6e22e">backend</span>.clone(),
</span></span><span style="display:flex;"><span>            healthy,
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>        .collect()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>get_healthy_backends</code> gets the list of servers we want to interrogate, and checks that their corresponding healthcheck endpoints are reachable and return a success code (HTTP 200).</p>
<p>I read an interesting post from Nicole Tietz-Sokolskaya (<a href="https://ntietz.com/blog/rusts-iterators-optimize-footgun/"  target="_blank" >here</a>) about the footguns presented by using rust iterators with async code. I didn&rsquo;t use her solution for waiting multiple futures, because I wanted to also collect all the results of the operations. Instead, I found the useful <a href="https://docs.rs/futures-preview/latest/i686-pc-windows-msvc/futures/future/fn.join_all.html"  target="_blank" >join_all</a> method in the futures crate, which is exactly what I needed for the task!</p>
<p>The <code>join_all</code> method receives a collection of futures and polls them, returning either the results of all the futures (in order) or an error if any future fails.</p>
<h2 id="extending-the-policy-with-healthchecks">Extending the policy with healthchecks</h2>
<p>With all the healthcheck results collected, we can now extend our Round-Robin policy to update the available backends:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[async_trait]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> RoutingPolicy {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">next</span>(<span style="color:#f92672">&amp;</span>self, request: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">HttpRequest</span>) -&gt; String;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// The new method we introduce
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">health_results</span>(<span style="color:#f92672">&amp;</span>self, results: Vec<span style="color:#f92672">&lt;</span>HealthResult<span style="color:#f92672">&gt;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We need to test that the policy will be affected by the results of our healthcheck loop. Given that our acceptance test will fail until we perform real HTTP requests and integrate multiple components, let&rsquo;s write a smaller test just for the policy:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[tokio::test]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">round_robin_policy_with_healthcheck</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> backends <span style="color:#f92672">=</span> vec![
</span></span><span style="display:flex;"><span>		Backend {
</span></span><span style="display:flex;"><span>			healthcheck_path: <span style="color:#e6db74">&#34;/health&#34;</span>.into(),
</span></span><span style="display:flex;"><span>			url: <span style="color:#e6db74">&#34;test_url_1&#34;</span>.into(),
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>		Backend {
</span></span><span style="display:flex;"><span>			healthcheck_path: <span style="color:#e6db74">&#34;/health&#34;</span>.into(),
</span></span><span style="display:flex;"><span>			url: <span style="color:#e6db74">&#34;test_url_2&#34;</span>.into(),
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>		Backend {
</span></span><span style="display:flex;"><span>			healthcheck_path: <span style="color:#e6db74">&#34;/health&#34;</span>.into(),
</span></span><span style="display:flex;"><span>			url: <span style="color:#e6db74">&#34;test_url_3&#34;</span>.into(),
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>	];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> config <span style="color:#f92672">=</span> Config {
</span></span><span style="display:flex;"><span>		health_check_interval_secs: <span style="color:#ae81ff">3</span>,
</span></span><span style="display:flex;"><span>		backends: <span style="color:#a6e22e">backends</span>.clone(),
</span></span><span style="display:flex;"><span>	};
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> policy <span style="color:#f92672">=</span> RoundRobinPolicy::new(<span style="color:#f92672">&amp;</span>config);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> request <span style="color:#f92672">=</span> test::TestRequest::default().to_http_request();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	assert_eq!(<span style="color:#e6db74">&#34;test_url_1&#34;</span>, policy.next(<span style="color:#f92672">&amp;</span>request).<span style="color:#66d9ef">await</span>);
</span></span><span style="display:flex;"><span>	assert_eq!(<span style="color:#e6db74">&#34;test_url_2&#34;</span>, policy.next(<span style="color:#f92672">&amp;</span>request).<span style="color:#66d9ef">await</span>);
</span></span><span style="display:flex;"><span>	assert_eq!(<span style="color:#e6db74">&#34;test_url_3&#34;</span>, policy.next(<span style="color:#f92672">&amp;</span>request).<span style="color:#66d9ef">await</span>);
</span></span><span style="display:flex;"><span>	assert_eq!(<span style="color:#e6db74">&#34;test_url_1&#34;</span>, policy.next(<span style="color:#f92672">&amp;</span>request).<span style="color:#66d9ef">await</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	policy
</span></span><span style="display:flex;"><span>		.health_results(vec![
</span></span><span style="display:flex;"><span>			HealthResult {
</span></span><span style="display:flex;"><span>				backend: <span style="color:#a6e22e">backends</span>[<span style="color:#ae81ff">0</span>].clone(),
</span></span><span style="display:flex;"><span>				healthy: <span style="color:#a6e22e">false</span>,
</span></span><span style="display:flex;"><span>			},
</span></span><span style="display:flex;"><span>			HealthResult {
</span></span><span style="display:flex;"><span>				backend: <span style="color:#a6e22e">backends</span>[<span style="color:#ae81ff">1</span>].clone(),
</span></span><span style="display:flex;"><span>				healthy: <span style="color:#a6e22e">true</span>,
</span></span><span style="display:flex;"><span>			},
</span></span><span style="display:flex;"><span>			HealthResult {
</span></span><span style="display:flex;"><span>				backend: <span style="color:#a6e22e">backends</span>[<span style="color:#ae81ff">2</span>].clone(),
</span></span><span style="display:flex;"><span>				healthy: <span style="color:#a6e22e">true</span>,
</span></span><span style="display:flex;"><span>			},
</span></span><span style="display:flex;"><span>		])
</span></span><span style="display:flex;"><span>		.<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	assert_eq!(<span style="color:#e6db74">&#34;test_url_2&#34;</span>, policy.next(<span style="color:#f92672">&amp;</span>request).<span style="color:#66d9ef">await</span>);
</span></span><span style="display:flex;"><span>	assert_eq!(<span style="color:#e6db74">&#34;test_url_3&#34;</span>, policy.next(<span style="color:#f92672">&amp;</span>request).<span style="color:#66d9ef">await</span>);
</span></span><span style="display:flex;"><span>	assert_eq!(<span style="color:#e6db74">&#34;test_url_2&#34;</span>, policy.next(<span style="color:#f92672">&amp;</span>request).<span style="color:#66d9ef">await</span>);
</span></span><span style="display:flex;"><span>	assert_eq!(<span style="color:#e6db74">&#34;test_url_3&#34;</span>, policy.next(<span style="color:#f92672">&amp;</span>request).<span style="color:#66d9ef">await</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here we are checking that the policy works as inteded in a round-robin fashion (the first assertions) as it was in part 2. Then, we send a healthcheck result saying that the first server is not available, and expect to only get the second/third servers in return.</p>
<p>Let&rsquo;s make this test pass!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">RoundRobinPolicy</span> {
</span></span><span style="display:flex;"><span>    backends: <span style="color:#a6e22e">RwLock</span><span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>    idx: <span style="color:#a6e22e">AtomicUsize</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[async_trait]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> RoutingPolicy <span style="color:#66d9ef">for</span> RoundRobinPolicy {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">next</span>(<span style="color:#f92672">&amp;</span>self, _request: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">HttpRequest</span>) -&gt; String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> idx <span style="color:#f92672">=</span> self.idx.fetch_add(<span style="color:#ae81ff">1</span>, Ordering::Relaxed);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Get read lock and return the correct server
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">let</span> servers <span style="color:#f92672">=</span> self.backends.read().<span style="color:#66d9ef">await</span>.clone();
</span></span><span style="display:flex;"><span>        servers.get(idx <span style="color:#f92672">%</span> servers.len()).unwrap().clone()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">health_results</span>(<span style="color:#f92672">&amp;</span>self, results: Vec<span style="color:#f92672">&lt;</span>HealthResult<span style="color:#f92672">&gt;</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Get write lock and overwrite the servers list
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> servers <span style="color:#f92672">=</span> self.backends.write().<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>servers <span style="color:#f92672">=</span> results
</span></span><span style="display:flex;"><span>            .iter()
</span></span><span style="display:flex;"><span>            .filter(<span style="color:#f92672">|</span>r<span style="color:#f92672">|</span> r.is_healthy())
</span></span><span style="display:flex;"><span>            .map(<span style="color:#f92672">|</span>r<span style="color:#f92672">|</span> r.backend.url.clone())
</span></span><span style="display:flex;"><span>            .collect();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>What is the difference from the implementation we did last time?</p>
<p>While in part 2 the <code>backends</code> variable was readonly (initialised at the beginning of the program), now the list of available servers can change at runtime, based on the healthcheck results. But our policy might be used concurrently, and rust doesn&rsquo;t allow concurrent access to <code>Vec</code> (also, our vector was immutable).</p>
<p>A <a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html"  target="_blank" >RwLock</a> allows us to read and mutate the backends vector in a thread-safe way. It does so by keeping a lock on the resource (the <code>Vec&lt;Backend&gt;</code>) but in an <em>asymmetric</em> way. In fact, it&rsquo;s possible to have multiple readers at the same time, but whenever a writer wants to mutate the resource (e.g. us, when we receive the healthcheck results), it gets exclusive access.</p>
<h3 id="integrating-everything-together">Integrating everything together</h3>
<p>Now that we have both the polling mechanism and the upgraded policy, it&rsquo;s time to integrate the two and finally make the acceptance test pass!</p>
<p>What we need to do is to periodically call the <code>get_healthy_backends</code> method and forward its results to the policy.</p>
<p>I wanted to have a nice discussion on how to use <a href="https://doc.rust-lang.org/rust-by-example/std_misc/channels.html"  target="_blank" >channels</a> to communicate among multiple tasks/thread, but I ended up simplifying the code and using a single task 🥲 here it is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">run</span>(<span style="color:#f92672">&amp;</span>self) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Start health check task
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> config_clone <span style="color:#f92672">=</span> self.config.clone();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> data_clone <span style="color:#f92672">=</span> self.data.clone();
</span></span><span style="display:flex;"><span>	tokio::spawn(<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> interval <span style="color:#f92672">=</span> interval(Duration::from_secs(
</span></span><span style="display:flex;"><span>			config_clone.health_check_interval_secs <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">u64</span>,
</span></span><span style="display:flex;"><span>		));
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> Client::new();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">loop</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">let</span> healthy_backends <span style="color:#f92672">=</span> get_healthy_backends(<span style="color:#f92672">&amp;</span>client, <span style="color:#f92672">&amp;</span>config_clone.backends).<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>			data_clone.policy.health_results(healthy_backends).<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>			interval.tick().<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	});
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Start http server
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> data_clone <span style="color:#f92672">=</span> self.data.clone();
</span></span><span style="display:flex;"><span>	HttpServer::new(<span style="color:#66d9ef">move</span> <span style="color:#f92672">||</span> {
</span></span><span style="display:flex;"><span>		App::new()
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">..</span>.
</span></span></code></pre></div><p>When the http server starts, we also start a concurrent task for the healthcheck procedure. The task runs on the interval we configure through the config struct, checks the availability of the backends and send the results to the policy.</p>
<p>That&rsquo;s all! Now the test pass, and we have just added a healthcheck procedure to our load balancer.</p>
<h2 id="conclusions">Conclusions</h2>
<p>We have implemented a simple HTTP load balancer, with a round-robin policy and healthcheck procedure.</p>
<p>What&rsquo;s missing?</p>
<p>For the sake of brevity, I didn&rsquo;t include config management, command line arguments and error management. All of this is left as exercise for the reader (you can find the entire project on the <a href="https://github.com/marcobacis/coding-challenges/tree/main/load_balancer"  target="_blank" >repo</a>).</p>
<p>I didn&rsquo;t implement other features needed by HTTP load balancers, such as <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For"  target="_blank" >X-Forwarded-For</a> and all additional headers. Finally, I don&rsquo;t know which version of HTTP this balancer supports (probably 1.1? I don&rsquo;t know). Basically, this was a nice exercise with async rust, but cannot be considered in any way to be production (or even test) ready!</p>
<p>I hope you still had fun and found the articles interesting. I certainly learned a lot in implementing this simple challenge, and hope to do more in the future!</p>
<p>Thanks a lot, and see you next time 👋</p>
<h2 id="resources">Resources</h2>
<ul>
<li><a href="https://actix.rs/docs"  target="_blank" >Actix Docs</a></li>
<li><a href="https://docs.rs/reqwest/latest/reqwest/"  target="_blank" >Reqwest Docs</a></li>
<li><a href="https://tokio.rs/tokio/tutorial"  target="_blank" >Tokio Tutorial</a></li>
<li><a href="https://doc.rust-lang.org/nomicon/send-and-sync.html"  target="_blank" >Send and Sync</a></li>
<li><a href="https://tontinton.com/posts/scheduling-internals/"  target="_blank" >Scheduling Internals</a> - Tony Solomonik</li>
<li><a href="https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/"  target="_blank" >Why async fn in traits are hard</a> - Niko Matsakis</li>
<li><a href="https://manishearth.github.io/blog/2015/05/27/wrapper-types-in-rust-choosing-your-guarantees/"  target="_blank" >Wrapper Types in Rust: Choosing Your Guarantees</a> - Manish Goregaokar</li>
<li><a href="https://ntietz.com/blog/rusts-iterators-optimize-footgun/"  target="_blank" >Rust&rsquo;s iterators optimize nicely—and contain a footgun</a></li>
</ul>

        ]]></content:encoded></item><item><title>Let's build a Load Balancer in Rust - Part 2</title><link>https://marcobacis.com/blog/load-balancer-rust-2/</link><pubDate>Wed, 22 May 2024 00:00:00 +0000</pubDate><guid>https://marcobacis.com/blog/load-balancer-rust-2/</guid><description>This is the second part of the &ldquo;Build your own load balancer in rust&rdquo; series! In this post, we&rsquo;ll see how to implement a round-robin policy, to forward our requests to multiple backends.</description><media:content url="https://marcobacis.com/blog/load-balancer-rust-2/cover_hu12279451129204478593.jpg" width="480" height="480" medium="image" type="image/jpeg"><media:thumbnail url="https://marcobacis.com/blog/load-balancer-rust-2/cover_hu12279451129204478593.jpg" width="480" height="480"/></media:content><content:encoded><![CDATA[
        <img src="https://marcobacis.com/blog/load-balancer-rust-2/cover_hu12279451129204478593.jpg" title="%!s(<nil>)" alt="%!s(<nil>)"/>
          




    <hr/>
    <div class="series-list">
        <h3>"Build your own load balancer in Rust" series</h3>
        <ul>
            
                <li>
                    
                        <a href="/blog/load-balancer-rust-1">Part 1: Setup and http forwarding</a>
                    
                </li>
            
                <li>
                    
                        Part 2: Round-Robin Policy
                    
                </li>
            
                <li>
                    
                        <a href="/blog/load-balancer-rust-3">Part 3: Healthcheck</a>
                    
                </li>
            
        </ul>
        <hr/>
    </div>

<p>Hi  👋 welcome to a new post! This is the second part of the series &ldquo;Let&rsquo;s build a Load Balancer in rust&rdquo;.</p>
<p>In the <a href="https://marcobacis.com/blog/load-balancer-rust-1/"  target="_blank" >first post</a> we saw how to forward a single request to an upstream server, using <a href="https://actix.rs/"  target="_blank" >Actix</a> and <a href="https://docs.rs/reqwest/latest/reqwest/"  target="_blank" >Reqwest</a>.</p>
<p>Today we&rsquo;ll see how to implement a round-robin policy, to forward our requests to multiple backends!</p>
<h2 id="small-fix-in-the-handler">Small fix in the handler</h2>
<p>In the first part, we left a (small) code smell in the handler code, because we instantiate the <code>reqwest</code> client struct on each new request received:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> Client::new();
</span></span></code></pre></div><p>The fix is simple: we can add the client to the shared app data, and then use it inside the handler! In this way, we won&rsquo;t have to istantiate the client on every request. This is also explained in reqwest <a href="https://docs.rs/reqwest/latest/reqwest/struct.Client.html"  target="_blank" >docs</a>: &ldquo;The <code>Client</code> holds a connection pool internally, so it is advised that you create one and <strong>reuse</strong> it.&rdquo;</p>
<p>I tried adding the client directly to the <code>LoadBalancer</code> struct without passing through Actix, but the compiler complained when defining the handler and I just left it as-is. If you know a better method, write a comment at the end of the post (or even better, create a PR on the <a href="https://github.com/marcobacis/coding-challenges/tree/main/load_balancer"  target="_blank" >project repository</a> 😁).</p>
<h2 id="waiting-for-the-load-balancer-to-start">Waiting for the Load Balancer to start</h2>
<p>Before starting with the round-robin implementation, lets tidy up a bit the code from the first part. The first thing to do is to improve the test we wrote!</p>
<p>In the test, we create the load balancer server and wait for it to start up with a simple `sleep´</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// The class under test, the load balancer itself
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> server <span style="color:#f92672">=</span> LoadBalancer::new(<span style="color:#ae81ff">8080</span>, vec![mock_server.uri()]);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> server_uri <span style="color:#f92672">=</span> server.uri();
</span></span><span style="display:flex;"><span>tokio::spawn(<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> { server.run().<span style="color:#66d9ef">await</span> });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Wait for the server to be up (will fix this later)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>tokio::time::sleep(std::time::Duration::from_secs(<span style="color:#ae81ff">3</span>)).<span style="color:#66d9ef">await</span>;
</span></span></code></pre></div><p>Well, let&rsquo;s fix this and create a function to wait for the server to start!</p>
<p>For now, we&rsquo;ll assume that the load balancer is up when the web server itself starts. To do so, we can add a healthcheck endpoint simply with actix:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>HttpServer::new(<span style="color:#66d9ef">move</span> <span style="color:#f92672">||</span> {
</span></span><span style="display:flex;"><span>	App::new()
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Healthcheck endpoint always returning 200 OK
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		.route(<span style="color:#e6db74">&#34;/health&#34;</span>, web::get().to(HttpResponse::Ok))
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Handler to forward request (from first part)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		.default_service(web::to(Self::handler))
</span></span><span style="display:flex;"><span>		.app_data(data.clone())
</span></span><span style="display:flex;"><span>	})
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// ...
</span></span></span></code></pre></div><p>To fix our test, we can wait for the healthcheck url to be available by trying multiple times and waiting for a 200 HTTP code. Here is an example function to do so:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">wait_server_up</span>(client: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Client</span>, uri: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>, max_retries: <span style="color:#66d9ef">usize</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> health_uri <span style="color:#f92672">=</span> format!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">/health&#34;</span>, uri);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> _ <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>max_retries {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> response <span style="color:#f92672">=</span> client.get(<span style="color:#f92672">&amp;</span>health_uri).send().<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> response.is_ok() {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		tokio::time::sleep(std::time::Duration::from_secs(<span style="color:#ae81ff">1</span>)).<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	panic!(<span style="color:#e6db74">&#34;Server didn&#39;t start...&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>With this method we can now replace the old <code>tokio::time::sleep</code>. Now we&rsquo;re ready to go on and start spamming multiple servers with our requests!</p>
<h2 id="creating-a-round-robin-policy">Creating a Round Robin Policy</h2>
<p>It&rsquo;s finally time to forward our requests among multiple servers!</p>
<p>Up until now, we have &ldquo;decided&rdquo; the upstream host to which we forward our requests in the <code>handler</code> method of the load balancer, but I think we should delegate and isolate this responsibility to a different module, such as a <em>Routing Policy</em>.</p>
<p>While our tests are still passing, we can afford to perform some <em><a href="https://martinfowler.com/articles/preparatory-refactoring-example.html"  target="_blank" >preparatory refactoring</a></em>. As said by <a href="https://x.com/KentBeck/status/250733358307500032?lang=en"  target="_blank" >kent beck</a>: &ldquo;<em>make the change easy, then make the easy change</em>&rdquo;.</p>
<h3 id="routing-policy-trait">Routing Policy Trait</h3>
<p>What we want to obtain is a simple interface for a routing policy, which chooses the next server on every new request we receive on the load balancer, like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[async_trait]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> RoutingPolicy {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">next</span>(<span style="color:#f92672">&amp;</span>self, request: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">HttpRequest</span>) -&gt; String;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>next</code> method takes the request reference and returns the host on which the load balancer should forward the request. We declare as <code>async</code> method, to indicate that the policy might wait for some I/O or other async operations (e.g. accessing shared data on the server, using a db/cache).</p>
<p>Why the <code>#[async_trait]</code> macro on top of the trait? The <a href="https://docs.rs/async-trait/latest/async_trait/"  target="_blank" >async_trait</a> crate allows to use a Trait containing async methods as <code>dyn</code> (e.g. use <code>dyn RoutingPolicy</code>, as we&rsquo;ll be doing below) instead of having to resort on generics to embed an async Trait inside another. The explanation is a bit complex (and I don&rsquo;t understand it completely 😅), so refer to the crate documentation for more infos.</p>
<p>We can now use the policy trait inside our program (I won&rsquo;t bother you with all the code, just the fundamental bits):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SafeRoutingPolicy</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">dyn</span> RoutingPolicy <span style="color:#f92672">+</span> Sync <span style="color:#f92672">+</span> Send;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// add policy to the load balancer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">LoadBalancer</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	data: <span style="color:#a6e22e">Data</span><span style="color:#f92672">&lt;</span>AppState<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// add policy to the app state
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">AppState</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	policy: Box<span style="color:#f92672">&lt;</span>SafeRoutingPolicy<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> LoadBalancer {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">handler</span>(req: <span style="color:#a6e22e">HttpRequest</span>,data: <span style="color:#a6e22e">web</span>::Data<span style="color:#f92672">&lt;</span>AppState<span style="color:#f92672">&gt;</span>,bytes: <span style="color:#a6e22e">web</span>::Bytes) -&gt; Result<span style="color:#f92672">&lt;</span>HttpResponse, Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Here we grab the next server host from the policy
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> server <span style="color:#f92672">=</span> data.policy.next(<span style="color:#f92672">&amp;</span>req).<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> uri <span style="color:#f92672">=</span> format!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}{}</span><span style="color:#e6db74">&#34;</span>, server, req.uri());
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// ... forward the request etc
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>Notice the type alias <code>SafeRoutingPolicy</code>, which has also the <code>Send</code> and <code>Sync</code> trait. Why do we need them? The policy is stored in the shared app state, which may be accessed by multiple threads (actix can run the handler method on different threads).</p>
<p>The <code>actix_web::web::Data</code> struct is a wrapper around an <code>Arc</code>, which allows to access the structure from multiple threads. However, that doesn&rsquo;t mean that the fields (e.g. the policy) are thread safe! This is also recalled by the compiler, which gives us a nice error if we don&rsquo;t require the policy to be <code>Sync + Send</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>error[E0277]: <span style="color:#960050;background-color:#1e0010">`</span>(<span style="color:#66d9ef">dyn</span> RoutingPolicy <span style="color:#f92672">+</span> &#39;static)<span style="color:#960050;background-color:#1e0010">`</span> cannot be shared between threads safely
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">-</span>-&gt; <span style="color:#a6e22e">src</span><span style="color:#f92672">/</span>lib.rs:<span style="color:#ae81ff">45</span>:<span style="color:#ae81ff">25</span>
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span>	  <span style="color:#75715e">// ... code
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   
</span></span><span style="display:flex;"><span><span style="color:#f92672">=</span> help: <span style="color:#a6e22e">the</span> <span style="color:#66d9ef">trait</span> <span style="color:#960050;background-color:#1e0010">`</span>Sync<span style="color:#960050;background-color:#1e0010">`</span> is not implemented <span style="color:#66d9ef">for</span> <span style="color:#960050;background-color:#1e0010">`</span>(<span style="color:#66d9ef">dyn</span> RoutingPolicy <span style="color:#f92672">+</span> &#39;static)<span style="color:#960050;background-color:#1e0010">`</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">=</span> note: <span style="color:#a6e22e">required</span> <span style="color:#66d9ef">for</span> <span style="color:#960050;background-color:#1e0010">`</span>Unique<span style="color:#f92672">&lt;</span>(<span style="color:#66d9ef">dyn</span> RoutingPolicy <span style="color:#f92672">+</span> &#39;static)<span style="color:#f92672">&gt;</span><span style="color:#960050;background-color:#1e0010">`</span> to implement <span style="color:#960050;background-color:#1e0010">`</span>Sync<span style="color:#960050;background-color:#1e0010">`</span>
</span></span><span style="display:flex;"><span>note: <span style="color:#a6e22e">required</span> because it appears within the <span style="color:#66d9ef">type</span> <span style="color:#960050;background-color:#1e0010">`</span>Box<span style="color:#f92672">&lt;</span>(<span style="color:#66d9ef">dyn</span> RoutingPolicy <span style="color:#f92672">+</span> &#39;static)<span style="color:#f92672">&gt;</span><span style="color:#960050;background-color:#1e0010">`</span>
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// ..Box
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">-</span>-&gt; <span style="color:#a6e22e">src</span><span style="color:#f92672">/</span>lib.rs:<span style="color:#ae81ff">22</span>:<span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">22</span>  <span style="color:#f92672">|</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">AppState</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span>        <span style="color:#f92672">^^^^^^^^</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">=</span> note: <span style="color:#a6e22e">required</span> <span style="color:#66d9ef">for</span> <span style="color:#960050;background-color:#1e0010">`</span>Arc<span style="color:#f92672">&lt;</span>AppState<span style="color:#f92672">&gt;</span><span style="color:#960050;background-color:#1e0010">`</span> to implement <span style="color:#960050;background-color:#1e0010">`</span>Send<span style="color:#960050;background-color:#1e0010">`</span>
</span></span><span style="display:flex;"><span>note: <span style="color:#a6e22e">required</span> because it appears within the <span style="color:#66d9ef">type</span> <span style="color:#960050;background-color:#1e0010">`</span>Data<span style="color:#f92672">&lt;</span>AppState<span style="color:#f92672">&gt;</span><span style="color:#960050;background-color:#1e0010">`</span>
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">90</span>  <span style="color:#f92672">|</span> <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Data</span><span style="color:#f92672">&lt;</span>T: <span style="color:#f92672">?</span>Sized<span style="color:#f92672">&gt;</span>(Arc<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span>            <span style="color:#f92672">^^^^</span>
</span></span><span style="display:flex;"><span>note: <span style="color:#a6e22e">required</span> because it<span style="color:#a6e22e">&#39;s</span> used within this closure
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">-</span>-&gt; <span style="color:#a6e22e">src</span><span style="color:#f92672">/</span>lib.rs:<span style="color:#ae81ff">45</span>:<span style="color:#ae81ff">25</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">45</span>  <span style="color:#f92672">|</span>         HttpServer::new(<span style="color:#66d9ef">move</span> <span style="color:#f92672">||</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span>                         <span style="color:#f92672">^^^^^^^</span>
</span></span><span style="display:flex;"><span>note: <span style="color:#a6e22e">required</span> by a bound <span style="color:#66d9ef">in</span> <span style="color:#960050;background-color:#1e0010">`</span>HttpServer::<span style="color:#f92672">&lt;</span>F, I, S, B<span style="color:#f92672">&gt;</span>::new<span style="color:#960050;background-color:#1e0010">`</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">-</span>-&gt; <span style="color:#f92672">/</span>Users<span style="color:#f92672">/</span>marco<span style="color:#f92672">/</span>.cargo<span style="color:#f92672">/</span>registry<span style="color:#f92672">/</span>src<span style="color:#f92672">/</span>index.crates.io<span style="color:#f92672">-</span><span style="color:#ae81ff">6</span>f17d22bba15001f<span style="color:#f92672">/</span>actix<span style="color:#f92672">-</span>web<span style="color:#f92672">-</span><span style="color:#ae81ff">4.5.1</span><span style="color:#f92672">/</span>src<span style="color:#f92672">/</span>server.rs:<span style="color:#ae81ff">94</span>:<span style="color:#ae81ff">20</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">94</span>  <span style="color:#f92672">|</span>     F: Fn() -&gt; <span style="color:#a6e22e">I</span> <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> Clone <span style="color:#f92672">+</span> &#39;static,
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span>                    <span style="color:#f92672">^^^^</span> required by this bound <span style="color:#66d9ef">in</span> <span style="color:#960050;background-color:#1e0010">`</span>HttpServer::<span style="color:#f92672">&lt;</span>F, I, S, B<span style="color:#f92672">&gt;</span>::new<span style="color:#960050;background-color:#1e0010">`</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// same for Sync
</span></span></span></code></pre></div><p>Basically, the compiler is telling us that the policy variable is not safe to move or access among multiple threads:</p>
<ul>
<li><code>Send</code> means a type can be moved/sent to another thread (e.g. when we run the server by spawning the actix http handler)</li>
<li><code>Sync</code>means that the type can be shared and use between threads (e.g. by calling the policy <code>next</code> method from different threads)</li>
</ul>
<p>This is one of the reasons I like rust: the compiler enforces us to use safe abstractions (e.g. forcing my policy to be <code>Sync</code>, a.k.a. thread safe) and explains that clearly in the compilation output!</p>
<h3 id="single-server-policy">Single Server Policy</h3>
<p>To finish our preparatory refactoring, we need to implement a routing policy which allows to always return a single server (the same thing we were doing in Part 1).</p>
<p>Let&rsquo;s implement it and run the tests:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">SingleServerPolicy</span> {
</span></span><span style="display:flex;"><span>	server: String,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> SingleServerPolicy {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(server: String) -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>		Self { server: <span style="color:#a6e22e">server</span> }
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[async_trait]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> RoutingPolicy <span style="color:#66d9ef">for</span> SingleServerPolicy {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">next</span>(<span style="color:#f92672">&amp;</span>self, request: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">HttpRequest</span>) -&gt; String {
</span></span><span style="display:flex;"><span>		self.server.clone()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Notice the use of <code>#[async_trait]</code> here too, as it needs to be applied also to the async trait&rsquo;s implementation.</p>
<p>We can now remove the list of servers from the LoadBalancer struct (and constructor) and move it inside the policy, and we are ready to implement our round robin policy!!</p>
<h3 id="round-robin-policy-test">Round Robin Policy: Test</h3>
<p>The first thing to do is to write another test case for our load balancer, this time spawning multiple upstream servers and checking that they are called in the right order:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[tokio::test]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">test_round_robin_three_servers</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> mocks <span style="color:#f92672">=</span> [
</span></span><span style="display:flex;"><span>		MockServer::start().<span style="color:#66d9ef">await</span>,
</span></span><span style="display:flex;"><span>		MockServer::start().<span style="color:#66d9ef">await</span>,
</span></span><span style="display:flex;"><span>		MockServer::start().<span style="color:#66d9ef">await</span>,
</span></span><span style="display:flex;"><span>	];
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	Mock::given(method(<span style="color:#e6db74">&#34;GET&#34;</span>))
</span></span><span style="display:flex;"><span>	.respond_with(ResponseTemplate::new(<span style="color:#ae81ff">200</span>).set_body_string(<span style="color:#e6db74">&#34;1&#34;</span>))
</span></span><span style="display:flex;"><span>	.mount(<span style="color:#f92672">&amp;</span>mocks[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>	.<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// ... same for mock server 2 and 3, returning a different number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> Client::new();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> mock_uris: Vec<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> mocks.iter().map(<span style="color:#f92672">|</span>mock<span style="color:#f92672">|</span> mock.uri()).collect();
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Spawn load balancer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> policy <span style="color:#f92672">=</span> Box::new(RoundRobinPolicy::new(mock_uris.clone()));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> server <span style="color:#f92672">=</span> LoadBalancer::new(<span style="color:#ae81ff">8082</span>, policy);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> server_uri <span style="color:#f92672">=</span> server.uri();
</span></span><span style="display:flex;"><span>	tokio::spawn(<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> { server.run().<span style="color:#66d9ef">await</span> });
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	wait_server_up(<span style="color:#f92672">&amp;</span>client, <span style="color:#f92672">&amp;</span>server_uri, <span style="color:#ae81ff">3</span>).<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Send requests, expect to respond in round robin (1,2,3,1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> response <span style="color:#f92672">=</span> client.get(<span style="color:#f92672">&amp;</span>server_uri).send().<span style="color:#66d9ef">await</span>.unwrap();
</span></span><span style="display:flex;"><span>	assert_eq!(StatusCode::<span style="color:#66d9ef">OK</span>, response.status());
</span></span><span style="display:flex;"><span>	assert_eq!(<span style="color:#e6db74">&#34;1&#34;</span>, response.text().<span style="color:#66d9ef">await</span>.unwrap());
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> response <span style="color:#f92672">=</span> client.get(<span style="color:#f92672">&amp;</span>server_uri).send().<span style="color:#66d9ef">await</span>.unwrap();
</span></span><span style="display:flex;"><span>	assert_eq!(StatusCode::<span style="color:#66d9ef">OK</span>, response.status());
</span></span><span style="display:flex;"><span>	assert_eq!(<span style="color:#e6db74">&#34;2&#34;</span>, response.text().<span style="color:#66d9ef">await</span>.unwrap());
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> response <span style="color:#f92672">=</span> client.get(<span style="color:#f92672">&amp;</span>server_uri).send().<span style="color:#66d9ef">await</span>.unwrap();
</span></span><span style="display:flex;"><span>	assert_eq!(StatusCode::<span style="color:#66d9ef">OK</span>, response.status());
</span></span><span style="display:flex;"><span>	assert_eq!(<span style="color:#e6db74">&#34;3&#34;</span>, response.text().<span style="color:#66d9ef">await</span>.unwrap());
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> response <span style="color:#f92672">=</span> client.get(<span style="color:#f92672">&amp;</span>server_uri).send().<span style="color:#66d9ef">await</span>.unwrap();
</span></span><span style="display:flex;"><span>	assert_eq!(StatusCode::<span style="color:#66d9ef">OK</span>, response.status());
</span></span><span style="display:flex;"><span>	assert_eq!(<span style="color:#e6db74">&#34;1&#34;</span>, response.text().<span style="color:#66d9ef">await</span>.unwrap());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Right now the test doesn&rsquo;t even compile (we don&rsquo;t have a <code>RoundRobinPolicy</code>struct with a <code>new</code> method).</p>
<p>Let&rsquo;s fix that.</p>
<h3 id="round-robin-policy-implementation">Round Robin Policy: Implementation</h3>
<p>Here is the code for the <code>RoundRobinPolicy</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">RoundRobinPolicy</span> {
</span></span><span style="display:flex;"><span>	servers: Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>	idx: <span style="color:#a6e22e">AtomicUsize</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> RoundRobinPolicy {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(servers: Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>		Self {
</span></span><span style="display:flex;"><span>			idx: <span style="color:#a6e22e">AtomicUsize</span>::new(<span style="color:#ae81ff">0</span>),
</span></span><span style="display:flex;"><span>			servers: <span style="color:#a6e22e">servers</span>.clone(),
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[async_trait]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> RoutingPolicy <span style="color:#66d9ef">for</span> RoundRobinPolicy {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">next</span>(<span style="color:#f92672">&amp;</span>self, _request: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">HttpRequest</span>) -&gt; String {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Read servers list
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">let</span> servers <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>self.servers;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> max_server_idx <span style="color:#f92672">=</span> servers.len() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	  
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Update index
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">let</span> idx <span style="color:#f92672">=</span> self
</span></span><span style="display:flex;"><span>		.idx
</span></span><span style="display:flex;"><span>		.fetch_update(Ordering::Relaxed, Ordering::Relaxed, <span style="color:#f92672">|</span>idx<span style="color:#f92672">|</span> <span style="color:#66d9ef">match</span> idx {
</span></span><span style="display:flex;"><span>			x <span style="color:#66d9ef">if</span> x <span style="color:#f92672">&gt;=</span> max_server_idx <span style="color:#f92672">=&gt;</span> Some(<span style="color:#ae81ff">0</span>),
</span></span><span style="display:flex;"><span>			c <span style="color:#f92672">=&gt;</span> Some(c <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>),
</span></span><span style="display:flex;"><span>		})
</span></span><span style="display:flex;"><span>		.unwrap_or_default();
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Return next server to forward the request to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		servers.get(idx).unwrap().clone()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>On each new request, the policy updates the current upstream server index and returns the corresponding url.</p>
<p>But why is the <code>idx</code> parameter an <code>AtomicUsize</code>? As explained in the <a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicUsize.html"  target="_blank" >documentation</a>, this type allows to safely share the underlying value between threads, as it can be updated atomically. In fact, we update the index with the <code>fetch_update</code> method, which allows to update the number and get the value in a single action, without risking data races and inconsistency when used by multiple threads.</p>
<p>The <code>Ordering:Relaxed</code>params indicate the ordering constraint to be enforced on the atomic operation. I tried to read the <a href="https://doc.rust-lang.org/nomicon/atomics.html"  target="_blank" >book</a> but didn&rsquo;t understand it completely, so refer to that to learn more about this. For now, we&rsquo;re ok using <code>Relaxed</code> (we are updating a counter and nothing more).</p>
<p>Now we have a round robin policy and the test passes. We can also replace the <code>SingleServerPolicy</code> created earlier with our new one and remove that temporary struct used for the refactoring!</p>
<h2 id="conclusions">Conclusions</h2>
<p>This is the end of Part 2. We cleaned up the load balancer code from <a href="https://marcobacis.com/blog/load-balancer-rust-1/"  target="_blank" >Part 1</a>, and added a simple Round-Robin policy to balance the load among multiple upstream servers. The code for this part can be found <a href="https://gist.github.com/marcobacis/477191a3b908c27fd334137cf4b5ee1d"  target="_blank" >here</a>.</p>
<p>Still, the <a href="https://codingchallenges.fyi/challenges/challenge-load-balancer"  target="_blank" >coding challenge</a> is not finished&hellip;.the final step will be to periodically health check the upstream servers, in order to not forward the requests to the unavailable ones.</p>
<p>See you next time for Part 3!</p>
<h2 id="resources">Resources</h2>
<ul>
<li><a href="https://actix.rs/docs"  target="_blank" >Actix Docs</a></li>
<li><a href="https://docs.rs/reqwest/latest/reqwest/"  target="_blank" >Reqwest Docs</a></li>
<li><a href="https://tokio.rs/tokio/tutorial"  target="_blank" >Tokio Tutorial</a></li>
<li><a href="https://doc.rust-lang.org/nomicon/send-and-sync.html"  target="_blank" >Send and Sync</a></li>
<li><a href="https://tontinton.com/posts/scheduling-internals/"  target="_blank" >Scheduling Internals</a> - Tony Solomonik</li>
<li><a href="https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/"  target="_blank" >Why async fn in traits are hard</a> - Niko Matsakis</li>
<li><a href="https://manishearth.github.io/blog/2015/05/27/wrapper-types-in-rust-choosing-your-guarantees/"  target="_blank" >Wrapper Types in Rust: Choosing Your Guarantees</a> - Manish Goregaokar</li>
</ul>

        ]]></content:encoded></item><item><title>Let's build a Load Balancer in Rust - Part 1</title><link>https://marcobacis.com/blog/load-balancer-rust-1/</link><pubDate>Sat, 11 May 2024 00:00:00 +0000</pubDate><guid>https://marcobacis.com/blog/load-balancer-rust-1/</guid><description>Hi 👋 welcome to a new post! This will be the first of a short series of posts, in which I explain my poor attempt at creating a simple HTTP load balancer in Rust. In this first part, we create a simple HTTP forwarder to a single upstream server.</description><media:content url="https://marcobacis.com/blog/load-balancer-rust-1/cover_hu12279451129204478593.jpg" width="480" height="480" medium="image" type="image/jpeg"><media:thumbnail url="https://marcobacis.com/blog/load-balancer-rust-1/cover_hu12279451129204478593.jpg" width="480" height="480"/></media:content><content:encoded><![CDATA[
        <img src="https://marcobacis.com/blog/load-balancer-rust-1/cover_hu12279451129204478593.jpg" title="%!s(<nil>)" alt="%!s(<nil>)"/>
          




    <hr/>
    <div class="series-list">
        <h3>"Build your own load balancer in Rust" series</h3>
        <ul>
            
                <li>
                    
                        Part 1: Setup and http forwarding
                    
                </li>
            
                <li>
                    
                        <a href="/blog/load-balancer-rust-2">Part 2: Round-Robin Policy</a>
                    
                </li>
            
                <li>
                    
                        <a href="/blog/load-balancer-rust-3">Part 3: Healthcheck</a>
                    
                </li>
            
        </ul>
        <hr/>
    </div>

<p>Hi 👋 welcome to a new post!</p>
<p>This will be the first of a short series of posts, in which I explain my poor attempt at creating a simple HTTP load balancer in Rust.</p>
<p>Why a load balancer, and why rust?</p>
<p>I came across this challenge on the <a href="https://codingchallenges.fyi/"  target="_blank" >Coding Challenges</a> newsletter. I had already completed the first challenges (implementing <code>wc</code> and <code>cut</code>), and I thought it was time for a more complex project.</p>
<p>A load balancer provides tons of challenge and can be approached at different levels. From a simple round-robin strategy, to weights, connection pools, asynchronous I/O and much more!</p>
<p>Why Rust? Well, I&rsquo;ve been tinkering with rust for the past year, mostly by solving advent of code problems. It&rsquo;s a high performance, low level language with a mixture of features (e.g. statically typed, not garbage collected, borrow checker, pattern matching and other functional stuff, and zero-cost abstractions) that make it a &ldquo;different&rdquo; language from the ones I usually use at work (C# and a bit of Typescript).</p>
<p>It also sits on a &ldquo;lower&rdquo; level from my usual projects (it&rsquo;s mostly used as a system programming language and in infrastructure), and I think it&rsquo;s cool to learn about the technology which keep my stuff running under the hood!</p>
<p>Also, it&rsquo;s a hyped language 😎, and why shouldn&rsquo;t I try it? Following trends shouldn&rsquo;t always be bad .</p>
<p>A side note: I developed part of the load balancer during the <a href="https://www.meetup.com/it-IT/open-source-saturday-milano/"  target="_blank" >Open Source Saturday Milan</a> meetup, with the help of <a href="https://github.com/MarcoIeni"  target="_blank" >Marco Ieni</a>. Marco is a rust expert and author of many rust crates and projects (e.g. his <a href="https://github.com/MarcoIeni/release-plz"  target="_blank" >release-plz</a> crate, which is fantastic) and he was of great help during the day. Without him, I would have taken a lot more time to setup the project and learn about Arc, Mutex and other async and multithread stuff! Thanks Marco for the help.</p>
<h2 id="load-balancer-basics">Load Balancer basics</h2>
<p>A load balancer is an application which sits in front of a group of servers, and routes the connection/requests across the servers in the group. By routing the requests to multiple backends, it allows to maximise availability (when a server goes down, requests can be redirected to the other servers in the pool) and utilisation (trying to use all servers at their maximum while keeping the latency low).</p>
<p>A load balancer can operate on different levels of the <a href="https://en.wikipedia.org/wiki/OSI_model"  target="_blank" >OSI model</a> (e.g. level 7, the application level, or level 4, the transport layer) with their advantages, disadvantages and numerous nuances.</p>
<p>In my case, the challenge was to create a simple load balancer working at the application level, forwarding HTTP requests. In this first post, we&rsquo;ll see a basic application forwarding HTTP requests to a single server.</p>
<h2 id="project-setup-and-a-first-test">Project setup and a first test</h2>
<p>Let&rsquo;s start the challenge by creating the basic project in rust and writing a simple test. At first I started by coding the simplest application possible without any tests, but Marco showed me how to setup a simple (unit? integration? I  don&rsquo;t know) test for it, so let&rsquo;s do it the proper way 😅.</p>
<p><em>Disclaimer: the snippets I post here won&rsquo;t compile most of the time, if you want the complete and updated code (with spoilers) see the <a href="https://github.com/marcobacis/coding-challenges/tree/main/load_balancer"  target="_blank" >repository</a></em></p>
<p>First, let&rsquo;s create the project with cargo:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cargo new lb
</span></span></code></pre></div><p>A common practice is to create a lib inside the crate, in order to extract common behaviour and keep the binary clean. This is a first version of the <code>cargo.toml</code>file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-toml" data-lang="toml"><span style="display:flex;"><span>[<span style="color:#a6e22e">package</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">name</span> = <span style="color:#e6db74">&#34;lb&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">version</span> = <span style="color:#e6db74">&#34;0.1.0&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">edition</span> = <span style="color:#e6db74">&#34;2021&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[<span style="color:#a6e22e">lib</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">name</span> = <span style="color:#e6db74">&#34;lb&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">path</span> = <span style="color:#e6db74">&#34;src/lib.rs&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[[<span style="color:#a6e22e">bin</span>]]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">name</span> = <span style="color:#e6db74">&#34;lb&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">path</span> = <span style="color:#e6db74">&#34;src/bin.rs&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[<span style="color:#a6e22e">dependencies</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">actix-web</span> = <span style="color:#e6db74">&#34;4.5.1&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">clap</span> = <span style="color:#e6db74">&#34;4.5.2&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">reqwest</span> = <span style="color:#e6db74">&#34;0.11.25&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">tokio</span> = { <span style="color:#a6e22e">version</span>=<span style="color:#e6db74">&#34;1.36.0&#34;</span>, <span style="color:#a6e22e">features</span> = [<span style="color:#e6db74">&#34;macros&#34;</span>, <span style="color:#e6db74">&#34;rt-multi-thread&#34;</span>] }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[<span style="color:#a6e22e">dev-dependencies</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">wiremock</span> = <span style="color:#e6db74">&#34;0.6.0&#34;</span>
</span></span></code></pre></div><p>as you can see, right now I&rsquo;m using <code>actix-web</code> as http framework to receive requests, and <code>reqwest</code> to forward them. I decided to not go too deep (managing sockets and http parsing) at the beginning, given that I&rsquo;m not familiar with rust frameworks and libraries yet.</p>
<p>Time for the first test!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[tokio::test]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">test_get_root</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Setup a mock upstream server, to test 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// that the request gets forwarded to it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> mock_server <span style="color:#f92672">=</span> MockServer::start().<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>	Mock::given(method(<span style="color:#e6db74">&#34;GET&#34;</span>))
</span></span><span style="display:flex;"><span>		.respond_with(
</span></span><span style="display:flex;"><span>			ResponseTemplate::new(<span style="color:#ae81ff">200</span>)
</span></span><span style="display:flex;"><span>			.set_body_string(<span style="color:#e6db74">&#34;backend&#34;</span>)
</span></span><span style="display:flex;"><span>		)
</span></span><span style="display:flex;"><span>		.expect(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>		.mount(<span style="color:#f92672">&amp;</span>mock_server)
</span></span><span style="display:flex;"><span>		.<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> Client::new();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// The class under test, the load balancer itself
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> server <span style="color:#f92672">=</span> LoadBalancer::new(<span style="color:#ae81ff">8080</span>, vec![mock_server.uri()]);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> server_uri <span style="color:#f92672">=</span> server.uri();
</span></span><span style="display:flex;"><span>	tokio::spawn(<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> { server.run().<span style="color:#66d9ef">await</span> });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Wait for the server to be up (will fix this later)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	tokio::time::sleep(std::time::Duration::from_secs(<span style="color:#ae81ff">3</span>)).<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Check that we receive response from the mock backend
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// (and not from the load balancer)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> response <span style="color:#f92672">=</span> client.get(server_uri).send().<span style="color:#66d9ef">await</span>.unwrap();
</span></span><span style="display:flex;"><span>	assert_eq!(StatusCode::<span style="color:#66d9ef">OK</span>, response.status());
</span></span><span style="display:flex;"><span>	assert_eq!(<span style="color:#e6db74">&#34;backend&#34;</span>, response.text().<span style="color:#66d9ef">await</span>.unwrap());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In this first step, all we care is that the load balancer is able to forward the request to a single upstream server. We create a mock server (using the <code>wiremock</code>crate, thanks to Marco&rsquo;s advice) to check that the request gets forwarded to it, then instantiate the load balancer and send a simple GET to it.</p>
<p>In pure (A)TDD style, this test doesn&rsquo;t even compile at first. Let&rsquo;s create at least the struct and the method required.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">LoadBalancer</span> {
</span></span><span style="display:flex;"><span>	port: <span style="color:#66d9ef">u16</span>,
</span></span><span style="display:flex;"><span>	servers: Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> LoadBalancer {
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(port: <span style="color:#66d9ef">u16</span>, servers: Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>		LoadBalancer { port, servers }
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">uri</span>(<span style="color:#f92672">&amp;</span>self) -&gt; String {
</span></span><span style="display:flex;"><span>		format!(<span style="color:#e6db74">&#34;http://127.0.0.1:</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, self.port)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">run</span>(<span style="color:#f92672">&amp;</span>self) {}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Obviously, the test is still failing, giving a &ldquo;Connection refused&rdquo; error. We&rsquo;ll get a failing test until the end of this post :P</p>
<h2 id="creating-a-http-forwarder">Creating a HTTP forwarder</h2>
<p>Now, let&rsquo;s open a connection and listen to requests on the port we passed to the load balancer. For now, we&rsquo;ll return a 200 on every request. How can we do it? <a href="https://actix.rs/"  target="_blank" >Actix</a> is a powerful framework for creating web services with rust. It relies on some concepts like extractors and handlers (better explained in their <a href="https://actix.rs/docs/getting-started"  target="_blank" >documentation</a> than here) that allow to easily create http endpoints.</p>
<p>Let&rsquo;s setup a simple server to respond to every request:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> LoadBalancer {
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">/// ... previous methods
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">run</span>(<span style="color:#f92672">&amp;</span>self) {
</span></span><span style="display:flex;"><span>		HttpServer::new(<span style="color:#66d9ef">move</span> <span style="color:#f92672">||</span> App::new()
</span></span><span style="display:flex;"><span>			.default_service(web::to(handler))
</span></span><span style="display:flex;"><span>		)
</span></span><span style="display:flex;"><span>		.bind((<span style="color:#e6db74">&#34;127.0.0.1&#34;</span>, self.port))
</span></span><span style="display:flex;"><span>		.unwrap()
</span></span><span style="display:flex;"><span>		.run()
</span></span><span style="display:flex;"><span>		.<span style="color:#66d9ef">await</span>	
</span></span><span style="display:flex;"><span>		.unwrap();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">handler</span>(req: <span style="color:#a6e22e">HttpRequest</span>) -&gt; <span style="color:#a6e22e">HttpResponse</span> {
</span></span><span style="display:flex;"><span>	HttpResponse::Ok().body(<span style="color:#e6db74">&#34;hello!&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In the <code>run</code> method of our load balancer, we instantiate an Http server which receives any request and returns &ldquo;hello!&rdquo;. The <code>default_service</code> in actix is a catch-all method which receives any request not handled by other services. We use the <code>web::to</code> helper function to create a generic any-method handler (accepting any HTTP method such as GET, POST, PUT etc&hellip;).</p>
<p>Now, let&rsquo;s add some behaviour to the handler. We want it to forward the request to the (only) server we configured in our test. To do so, a first way is to just get the request, copy it and send it to the server, using <code>reqwest</code>. As I already said at the beginning of the post, my goal now is to create a simple proxy, without caring much about performance or functionality.</p>
<p>But how can we use the upstream server url in our request handler? Actix allows to share data between handlers using a concept called <a href="https://actix.rs/docs/application/#shared-mutable-state"  target="_blank" >web::Data</a>. It&rsquo;s a struct encapsulating an <code>Arc</code> (a thread-safe reference counting pointer) in which we can put data that must be shared (immutably or mutably) among handlers and requests.</p>
<p>First, let&rsquo;s define the data we want to share (the servers urls) and add it to the application.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">AppState</span> {
</span></span><span style="display:flex;"><span>	servers: Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">run</span>(<span style="color:#f92672">&amp;</span>self) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> data <span style="color:#f92672">=</span> web::Data::new(AppState {
</span></span><span style="display:flex;"><span>		servers: <span style="color:#a6e22e">self</span>.servers.clone(),
</span></span><span style="display:flex;"><span>	});
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	HttpServer::new(<span style="color:#66d9ef">move</span> <span style="color:#f92672">||</span> {
</span></span><span style="display:flex;"><span>		App::new()
</span></span><span style="display:flex;"><span>			.default_service(web::to(Self::handler))
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// We add the initial instance of our shared app state
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			.app_data(data.clone())
</span></span><span style="display:flex;"><span>	})
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// as above, bind and run ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>})
</span></span></code></pre></div><p>Then, we can use the shared data inside the handler using an <a href="https://actix.rs/docs/extractors"  target="_blank" >extractor</a>, a parameter used in the function to access parts of the request, or the application state in this case:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">handler</span>(req: <span style="color:#a6e22e">HttpRequest</span>, data: <span style="color:#a6e22e">web</span>::Data<span style="color:#f92672">&lt;</span>AppState<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">HttpResponse</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> server <span style="color:#f92672">=</span> data.servers[<span style="color:#ae81ff">0</span>].clone();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// do stuff with server url now
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	HttpResponse::Ok().body(<span style="color:#e6db74">&#34;hello&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Finally, it&rsquo;s time to forward the request! The code below is not so performant (it instantiates a reqwest client on every request, clones the headers betweeen the input and forwarded request, and so on..), but it works:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">handler</span>(
</span></span><span style="display:flex;"><span>	req: <span style="color:#a6e22e">HttpRequest</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Extractor used to get the shared application state
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	data: <span style="color:#a6e22e">web</span>::Data<span style="color:#f92672">&lt;</span>AppState<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Extractor used to get the request payload as raw bytes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	bytes: <span style="color:#a6e22e">web</span>::Bytes,
</span></span><span style="display:flex;"><span>) -&gt; Result<span style="color:#f92672">&lt;</span>HttpResponse, Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Get the address to which to forward the request
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> server <span style="color:#f92672">=</span> data.servers[<span style="color:#ae81ff">0</span>].clone();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> uri <span style="color:#f92672">=</span> format!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}{}</span><span style="color:#e6db74">&#34;</span>, server, req.uri());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Create the request
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> Client::new();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> request_builder <span style="color:#f92672">=</span> client
</span></span><span style="display:flex;"><span>		.request(req.method().clone(), uri)
</span></span><span style="display:flex;"><span>		.headers(req.headers().into())
</span></span><span style="display:flex;"><span>		.body(bytes);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Forward the request
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> response <span style="color:#f92672">=</span> request_builder.send().<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Get the response and send it back to the client
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> response_builder <span style="color:#f92672">=</span> HttpResponse::build(response.status());
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> h <span style="color:#66d9ef">in</span> response.headers().iter() {
</span></span><span style="display:flex;"><span>		response_builder.append_header(h);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> body <span style="color:#f92672">=</span> response.bytes().<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	Ok(response_builder.body(body))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>After this, the test passes, and we&rsquo;re all set! I left out the implementation of the <code>Error</code>  struct (it takes the <code>reqwest::Error</code> and stores it inside the struct, along with the implementation of the <code>From&lt;reqwest::Error&gt;</code> and <code>ResponseError</code> traits).</p>
<p>You can find the code of this simple HTTP forwarder <a href="https://gist.github.com/marcobacis/4ba9d0885862239d9ed7482983047472"  target="_blank" >here</a>. Also, I keep a repository to all the solutions I came up for coding challenges, <a href="https://github.com/marcobacis/coding-challenges"  target="_blank" >here</a>.</p>
<p>See you next time for part 2, in which we add a simple round-robin policy and transform our simple Proxy in a real (almost) LoadBalancer!</p>
<h2 id="resources">Resources</h2>
<ul>
<li><a href="https://actix.rs/docs"  target="_blank" >Actix Docs</a></li>
<li><a href="https://docs.rs/reqwest/latest/reqwest/"  target="_blank" >Reqwest Docs</a></li>
<li><a href="https://codingchallenges.fyi/"  target="_blank" >Coding Challenges Website</a></li>
<li><a href="https://www.nginx.com/resources/glossary/load-balancing/"  target="_blank" >What is Load Balancing?</a></li>
</ul>

        ]]></content:encoded></item></channel></rss>